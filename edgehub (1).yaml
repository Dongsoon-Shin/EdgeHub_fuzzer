data:
  admin:
    default:
      license:
        id: ""
        key: ""
      support:
        email: "support@interactor.com"
        phone: "+1 408 484 7780"
      system:
        name: "EdgeHub"
  base_dir:
    default: "C:/Users/USER/Documents/GitHub/LSIS-EdgeHub/ui/dist"
    persistent: true
  config:
    persistent: true
  defaultConfig:
    default:
      actions: []
      clients: []
      devices:
        - name: "Virtual"
          properties:
            category: "virtual"
      groups:
        - name: "_"
          properties:
            comment: ""
      mappings: []
      protocols:
        cnet:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - default: ""
              key: "port"
              name: "Port"
              type: "input"
              valueType: "text"
            - default: 255
              key: "uid"
              name: "Unique ID"
              type: "input"
              valueType: "number"
            - default: 115200
              key: "speed"
              name: "Baudrate"
              type: "input"
              valueType: "number"
            - default: 8
              key: "data_bits"
              name: "Data Bits"
              type: "input"
              valueType: "number"
            - default: "none"
              key: "parity"
              name: "Parity"
              type: "input"
              valueType: "text"
            - default: 1
              key: "stop_bits"
              name: "Stop Bits"
              type: "input"
              valueType: "number"
          serial: true
          tagInfo:
            - key: "address"
              name: "Start address"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - key: "length"
              name: "Length"
              type: "input"
              valueType: "number"
          text: "CNET"
        fenet:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - default: "127.0.0.1"
              key: "address"
              name: "Address"
              type: "input"
              valueType: "text"
            - default: 2004
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
            - default: 0
              key: "slot"
              name: "Slot"
              type: "input"
              valueType: "number"
            - default: 0
              key: "base"
              name: "Base"
              type: "input"
              valueType: "number"
            - default: "LSIS-XGT"
              key: "company_id"
              name: "Company ID"
              options:
                - key: "LSIS-XGT"
                  text: "LSIS-XGT"
                - key: "LSIS-GLOFA"
                  text: "LSIS-GLOFA"
              type: "select"
            - default: "XGI"
              key: "cpu_info"
              name: "CPU Info"
              options:
                - key: "XGK"
                  text: "XGK"
                - key: "XGI"
                  text: "XGI"
                - key: "XGR"
                  text: "XGR"
              type: "select"
          tagInfo:
            - key: "address"
              name: "Start address"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - key: "length"
              name: "Length"
              type: "input"
              valueType: "number"
          text: "FENET"
        http server:
          builtIn: true
          category: "server"
          config: {}
          connectionInfo:
            - default: 2290
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
          text: "HTTP"
        mariadb:
          builtIn: true
          category: "database"
          config: {}
          connectionInfo:
            - default: "127.0.0.1"
              key: "address"
              name: "Address"
              type: "input"
              valueType: "text"
            - default: 3306
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
            - default: "EdgeHub"
              key: "database"
              name: "Database"
              type: "input"
              valueType: "text"
            - default: "root"
              key: "username"
              name: "Username"
              type: "input"
              valueType: "text"
            - default: ""
              key: "password"
              name: "Password"
              type: "input"
              valueType: "text"
            - default: ""
              key: "type"
              name: "Type"
              options:
                - key: "edgehub"
                  text: "EdgeHub"
                - key: "custom"
                  text: "Custom"
              type: "select"
              valueType: "text"
          tagInfo:
            - key: "table"
              name: "Table"
              type: "input"
              valueType: "text"
            - key: "column"
              name: "Colunm"
              type: "input"
              valueType: "text"
            - key: "condition"
              name: "Condition"
              type: "input"
              valueType: "text"
          text: "MariaDB EdgeHub"
        mariadb custom:
          builtIn: true
          category: "database"
          config: {}
          connectionInfo:
            - default: "127.0.0.1"
              key: "address"
              name: "Address"
              type: "input"
              valueType: "text"
            - default: 3306
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
            - default: "EdgeHub"
              key: "database"
              name: "Database"
              type: "input"
              valueType: "text"
              namingRule: "id"
            - default: "root"
              key: "username"
              name: "Username"
              type: "input"
              valueType: "text"
              namingRule: "id"
            - default: ""
              key: "password"
              name: "Password"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - default: ""
              key: "type"
              name: "Type"
              options:
                - key: "edgehub"
                  text: "EdgeHub"
                - key: "custom"
                  text: "Custom"
              type: "select"
              valueType: "text"
          tagInfo:
            - key: "table"
              name: "Table"
              type: "input"
              valueType: "text"
            - key: "column"
              name: "Colunm"
              type: "input"
              valueType: "text"
            - key: "condition"
              name: "Condition"
              type: "input"
              valueType: "text"
          text: "MariaDB Custom"
        modbus rtu master:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - default: ""
              key: "port"
              name: "Port"
              type: "input"
              valueType: "text"
            - default: 255
              key: "uid"
              name: "Unique ID"
              type: "input"
              valueType: "number"
            - default: 115200
              key: "speed"
              name: "Baudrate"
              type: "input"
              valueType: "number"
            - default: 8
              key: "data_bits"
              name: "Data Bits"
              type: "input"
              valueType: "number"
            - default: "none"
              key: "parity"
              name: "Parity"
              type: "input"
              valueType: "text"
            - default: 1
              key: "stop_bits"
              name: "Stop Bits"
              type: "input"
              valueType: "number"
          serial: true
          tagInfo:
            - key: "address"
              name: "Start address"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - key: "length"
              name: "Length"
              type: "input"
              valueType: "number"
          text: "Modbus RTU"
        modbus tcp master:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - default: "127.0.0.1"
              key: "address"
              name: "Address"
              type: "input"
              valueType: "text"
            - default: 502
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
            - default: 255
              key: "uid"
              name: "Unique ID"
              type: "input"
              valueType: "number"
          tagInfo:
            - key: "address"
              name: "Start address"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - key: "length"
              name: "Length"
              type: "input"
              valueType: "number"
          text: "Modbus TCP"
        modbus tcp slave:
          builtIn: true
          category: "server"
          config: {}
          connectionInfo:
            - default: 502
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
            - default: "1"
              key: "uids"
              name: "UIDs"
              type: "input"
              valueType: "text"
          tagIdFields:
            - default: 1
              key: "id"
              name: "ID"
              type: "input"
              valueType: "number"
            - default: "register"
              key: "type"
              name: "Type"
              options:
                - key: "coil"
                  text: "Coil (0x)"
                - key: "discrete"
                  text: "Discrete Input (1x)"
                - key: "input"
                  text: "Input Register (3x)"
                - key: "holding"
                  text: "Holding Register (4x)"
              type: "select"
              valueType: "text"
            - default: 0
              key: "address"
              name: "Address"
              type: "input"
              valueType: "number"
          tagInfo:
            - key: "category"
              name: "Category"
              type: "categories"
              valueType: "text"
            - key: "group"
              name: "Group"
              type: "groups"
              valueType: "text"
            - key: "device"
              name: "Device"
              type: "devices"
              valueType: "text"
            - key: "tag"
              name: "Tag"
              type: "tags"
              valueType: "text"
          text: "Modbus TCP"
        opcua client:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - key: "address"
              name: "Address"
              type: "input"
              valueType: "text"
            - key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
          tagInfo:
            - key: "id"
              name: "Object ID"
              type: "input"
              valueType: "text"
          text: "OPC UA"
        opcua server:
          builtIn: true
          category: "server"
          config: {}
          connectionInfo:
            - key: "port"
              default: 53530
              name: "Port"
              type: "input"
              valueType: "number"
          tagInfo: []
          text: "OPC UA"
        melsec ethernet:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - default: "127.0.0.1"
              key: "address"
              name: "Address"
              type: "input"
              valueType: "text"
            - default: 5002
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
            - default: "00"
              key: "network_number"
              name: "Network Number"
              type: "input"
              valueType: "text"
            - default: "00"
              key: "station_number"
              name: "Station Number"
              type: "input"
              valueType: "text"
            - default: "FF"
              key: "plc_number"
              name: "PLC Number"
              type: "input"
              valueType: "text"
            - default: "03FF"
              key: "io_number"
              name: "IO Number"
              type: "input"
              valueType: "text"
            - default: "binary"
              key: "communication_type"
              name: "Communication Type"
              options:
                - key: "binary"
                  text: "Binary"
                - key: "ASCII"
                  text: "ASCII"
              type: "select"
          tagInfo:
            - key: "address"
              name: "Start address"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - key: "length"
              name: "Length"
              type: "input"
              valueType: "number"
          text: "MELSEC ETHERNET"
        melsec serial:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - default: ""
              key: "port"
              name: "Port"
              type: "input"
              valueType: "text"
            - default: 9600
              key: "speed"
              name: "Baudrate"
              type: "input"
              valueType: "number"
            - default: 8
              key: "data_bits"
              name: "Data Bits"
              type: "input"
              valueType: "number"
            - default: "none"
              key: "parity"
              name: "Parity"
              type: "input"
              valueType: "text"
            - default: 1
              key: "stop_bits"
              name: "Stop Bits"
              type: "input"
              valueType: "number"
            - default: "4F"
              key: "format"
              name: "Format"
              options:
                - key: "1F"
                  text: "1F"
                - key: "2F"
                  text: "2F"
                - key: "4F"
                  text: "4F"
              type: "select"
            - default: "4C"
              key: "frame"
              name: "Frame"
              options:
                - key: "2C"
                  text: "2C"
                - key: "3C"
                  text: "3C"
                - key: "4C"
                  text: "4C"
              type: "select"
            - default: "00"
              key: "num_station"
              name: "Station Number"
              type: "input"
              valueType: "text"
            - default: "FF"
              key: "num_station_self"
              name: "Self Station Number"
              type: "input"
              valueType: "text"
            - default: "00"
              key: "num_network"
              name: "Network number"
              type: "input"
              valueType: "text"
              condition:
                field: "frame"
                action: "includes"
                value:
                  - "3C"
                  - "4C"
            - default: "FF"
              key: "num_plc"
              name: "PLC number"
              type: "input"
              valueType: "text"
              condition:
                field: "frame"
                action: "includes"
                value:
                  - "3C"
                  - "4C"
            - default: "00"
              key: "request_dest_module_num_station"
              name: "Request Destination Module Station Number"
              type: "input"
              valueType: "text"
              condition:
                field: "frame"
                action: "includes"
                value:
                  - "4C"
            - default: "03FF"
              key: "request_dest_num_IO"
              name: "Request Destination I/O Number"
              type: "input"
              valueType: "text"
              condition:
                field: "frame"
                action: "includes"
                value:
                  - "3C"
                  - "4C"
          serial: true
          tagInfo:
            - key: "address"
              name: "Start address"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - key: "length"
              name: "Length"
              type: "input"
              valueType: "number"
          text: "MELSEC SERIAL"
      tags: []
    persistent: true
  function:
    default: |
      db_put:
        logic:
          $action: "elixir"
          value: |
            Log.info("db_put: v: #{inspect v}")
            category = v["tag"]["properties"]["_category"] || ""
            group = v["tag"]["properties"]["_group"] || ""
            device = v["tag"]["properties"]["_device"] || ""
            tag_name = v["tag"]["name"] || ""
            load_condition = v["tag"]["properties"]["_condition"]["_load_condition"] || ""
            body_string = cond do
              String.valid?(v["value"]) -> v["value"]
              is_binary(v["value"]) -> v["value"] |> Base.encode16()
              true -> inspect(v["value"])
            end
            tag_id = get(["tag_id", category, group, device, tag_name])
            query_value = "UPDATE tag SET tag_value = '#{body_string}' WHERE tag_id=#{tag_id};"
            edgehub_db_list = get("edgehub_db_list") || []
            edgehub_db_list |> Enum.each(fn db_name ->
              value_ret = instance(db_name, "query", query_value)
              if v["tag"]["properties"]["_condition"]["_history"] == "enable" do
                if ((load_condition == "") || function("parse_and_eval", %{"logic" => body_string <> " " <> load_condition, "allow_char" => false})) do
                  query_history = "INSERT INTO tag_history (tag_id, value) VALUES (#{tag_id}, '#{body_string}')"
                  history_ret = instance(db_name, "query", query_history)
                end
              end
            end)
      execute_actions:
        logic:
          $action: "elixir"
          value: |
            Log.info("execute_actions: v: #{inspect v}")
            category = v["tag"]["properties"]["_category"] || ""
            group = v["tag"]["properties"]["_group"] || ""
            device = v["tag"]["properties"]["_device"] || ""
            tag_name = v["tag"]["name"] || ""
            actions = get("actions") || []
            action_results = actions |> Enum.filter(fn action ->
              action_category = action["properties"]["_category"] || ""
              action_group = action["properties"]["_group"] || ""
              action_device = action["properties"]["_device"] || ""
              {action_category, action_group, action_device, Enum.at(action["idFields"], 0)} == {category, group, device, tag_name}
            end) |> Enum.each(fn filtered_action ->
              action_condition = Enum.at(filtered_action["idFields"], 1) || ""
              value = cond do
                is_binary(v["value"]) -> inspect v["value"]
                true -> inspect v["value"]
              end
              if (action_condition == "" || function("parse_and_eval", %{"logic" => value <> " " <> action_condition, "allow_char" => true})) do
                value_tmp = function("parse_and_eval", %{"logic" => filtered_action["properties"]["value"], "allow_char" => true})
                key = category <> "_" <> group <> "_" <> tag_name
                tags = get("tags") || []
                case Enum.at(filtered_action["idFields"], 2) do
                  "tag" ->
                    case filtered_action["properties"]["category"] do
                      "device" ->
                        tags |> Enum.find(fn tag ->
                          (tag["properties"]["_group"] == filtered_action["properties"]["group"]) && (tag["properties"]["_device"] == filtered_action["properties"]["device"]) && (tag["name"] == filtered_action["properties"]["tag"])
                        end)
                      "database" ->
                        tags |> Enum.find(fn tag ->
                          (tag["properties"]["_category"] == "database") && (tag["properties"]["_device"] == filtered_action["properties"]["device"]) && (tag["name"] == filtered_action["properties"]["tag"])
                        end)
                      "virtual" ->
                        tags |> Enum.find(fn tag ->
                          (tag["properties"]["_category"] == "virtual") && (tag["properties"]["_device"] == filtered_action["properties"]["device"]) && (tag["name"] == filtered_action["properties"]["tag"])
                        end)
                      _ -> ""
                    end
                  "log" ->
                    Log.info("EdgeHub: Action: Execute: " <> key <> ": value: " <> inspect(value_tmp))
                    ""
                  _ ->
                    Log.error("EdgeHub: Action: Error: id:" <> Enum.at(filtered_action["idFields"], 2) <> " key:" <> key <> " value: " <> inspect(value_tmp))
                    ""
                end |> case do
                  "" -> :ok
                  target ->
                    target_properties = target["properties"]
                    valueType = target_properties["_condition"]["valueType"]
                    {typed_value, typed_binary} = function("transform", %{
                      "value" => value_tmp,
                      "type" => valueType,
                      "path" => [
                        "action",
                        filtered_action["properties"]["_category"],
                        filtered_action["properties"]["_group"] || "",
                        filtered_action["properties"]["_device"],
                        filtered_action["name"]
                      ]
                    })
                    case target_properties["_category"] do
                      "virtual" ->
                        Log.info("execute_actions: virtual: #{inspect target_properties}")
                        function("save_tag_value", %{
                          "value" => value_tmp,
                          "valueType" => valueType,
                          "typed_value" => typed_value,
                          "typed_binary" => typed_binary,
                          "path" => [
                            "tag",
                            filtered_action["properties"]["category"],
                            filtered_action["properties"]["group"] || "",
                            filtered_action["properties"]["device"],
                            filtered_action["properties"]["tag"]
                          ]
                        })
                      _ ->
                        instance_name = if (target_properties["communication"]["serial"]) do
                          "Serial_Port_" <> target_properties["communication"]["data"]["port"]
                        else
                          "#{filtered_action["properties"]["group"]}/#{filtered_action["properties"]["device"]}"
                        end
                        new_condition = function("parse_condition", target_properties["_condition"])
                        instance(instance_name, "write_tag", %{"properties" => target_properties |> Map.put("_condition", new_condition), "value" => typed_value})
                    end
                end
              end
            end)
      hex_2_binary:
        logic:
          $action: "elixir"
          value: |
            require Integer
            if (String.contains?(v, ".")) do
              nil
            else
              clean_hex = v |> String.replace("0x", "") |> String.replace(~r/[^0-9a-fA-F]/, "")
              hex = case (clean_hex |> String.length() |> Integer.is_even()) do
                true -> clean_hex
                false -> <<48>> <> clean_hex
              end
              case (hex |> Base.decode16(case: :mixed)) do
                {:ok, typed_value} ->
                  case typed_value do
                    "" -> nil
                    _ -> typed_value
                  end
                :error -> nil
              end
            end
      int_size:
        logic:
          $action: "elixir"
          value: |
            ((((:math.log2(abs(v))/8) |> :math.floor()) + 1) * 8) |> trunc()
      save_tag_value:
        logic:
          $action: "elixir"
          value: |
            value = v["value"]
            valueType = v["valueType"]
            typed_value = v["typed_value"]
            typed_binary = v["typed_binary"]
            path = v["path"]
            binary_string = if (typed_binary), do: "0x" <> (typed_binary |> Base.encode16()), else: "N/A"
            value_string = if (typed_value) do
              case valueType do
                "int" -> typed_value |> inspect()
                "uint" -> typed_value |> inspect()
                "float" -> typed_value |> inspect()
                "binary" -> "0x" <> (typed_value |> Base.encode16())
                "string-hex" -> "0x" <> (typed_value |> Base.encode16())
                "string-int" -> typed_value |> inspect()
                "string-uint" -> typed_value |> inspect()
                "string-float" -> typed_value |> inspect()
                "string-ascii" -> typed_value |> inspect()
                "hex-int" -> typed_value |> inspect()
                "hex-uint" -> typed_value |> inspect()
                "hex-float" -> typed_value |> inspect()
                _ ->
                  "N/A"
              end
            else
              "N/A"
            end
            raw_string = if (is_binary(value)), do: "0x" <> (value |> Base.encode16()), else: inspect value
            set(["raw_string"] ++ path, raw_string)
            set(["raw"] ++ path, value)
            set(["value"] ++ path, typed_value)
            set(["value_string"] ++ path, value_string)
            set(["binary"] ++ path, typed_binary)
            set(["binary_string"] ++ path, binary_string)
            prev = if get(["timestamp"] ++ path ++ ["prev"]) === nil, do: 0, else: get(["timestamp"] ++ path ++ ["prev"])
            current = :os.system_time(:millisecond)
            set(["timestamp"] ++ path ++ ["gap"], (current - prev))
            set(["timestamp"] ++ path ++ ["prev"], current)
      transform:
        logic:
          $action: "elixir"
          value: |
            Log.info("function: transform: #{inspect v}")
            value = v["value"]
            valueType = v["type"]
            path = v["path"]
            {typed_value, typed_binary} = cond do
              is_float(value) ->
                case valueType do
                  "int" ->
                    typed_value = value |> trunc()
                    size = function("int_size", typed_value)
                    {typed_value, <<typed_value::signed-integer-size(size)>>}
                  "uint" ->
                    if (value < 0) do
                      {nil, nil}
                    else
                      typed_value = value |> trunc()
                      size = function("int_size", typed_value)
                      {typed_value, <<typed_value::unsigned-integer-size(size)>>}
                    end
                  "float" ->
                    {value, <<value::float>>}
                  "binary" ->
                    {<<value::float>>, <<value::float>>}
                  _ ->
                    {nil, nil}
                end
              is_integer(value) ->
                case valueType do
                  "int" ->
                    size = function("int_size", value)
                    {value, <<value::signed-integer-size(size)>>}
                  "uint" ->
                    if (value < 0) do
                      {nil, nil}
                    else
                      size = function("int_size", value)
                      {value, <<value::unsigned-integer-size(size)>>}
                    end
                  "float" ->
                    typed_value = value / 1
                    {typed_value, <<value::float>>}
                  "binary" ->
                    size = function("int_size", value)
                    {<<value::signed-integer-size(size)>>, <<value::signed-integer-size(size)>>}
                  _ ->
                    {nil, nil}
                end
              is_map(value) -> # Database value
                rows = value |> Map.get(:rows)
                case rows do
                  [[db_value]] -> db_value
                  [db_value] -> db_value
                  _ -> rows
                end
              is_binary(value) ->
                case valueType do
                  "int" ->
                    size = bit_size(value)
                    <<typed_value::signed-size(size)>> = value
                    {typed_value, value}
                  "uint" ->
                    size = bit_size(value)
                    <<typed_value::unsigned-size(size)>> = value
                    {typed_value, value}
                  "float" ->
                    case byte_size(value) do
                      4 ->
                        <<typed_value::float-size(32)>> = value
                        {typed_value, value}
                      8 ->
                        <<typed_value::float-size(64)>> = value
                        {typed_value, value}
                      _ ->
                        size = bit_size(value)
                        <<signed_value::signed-size(size)>> = value
                        <<unsigned_value::unsigned-size(size)>> = value
                        if (signed_value == unsigned_value) do
                          {signed_value/1, <<signed_value::float>>}
                        else
                          {nil, nil}
                        end
                    end
                  "binary" ->
                    {value, value}
                  "string-hex" ->
                    typed_value = function("hex_2_binary", value)
                    if (typed_value), do: {typed_value, typed_value}, else: {nil, nil}
                  "string-int" ->
                    case (value |> String.trim() |> Integer.parse()) do
                      {typed_value, _} ->
                        size = function("int_size", typed_value)
                        {typed_value, <<typed_value::signed-integer-size(size)>>}
                      :error -> {nil, nil}
                    end
                  "string-uint" ->
                    case (value |> String.trim() |> Integer.parse()) do
                      {val, _} ->
                        if (val < 0) do
                          {nil, nil}
                        else
                          typed_value = val |> abs()
                          size = function("int_size", typed_value)
                          {typed_value, <<typed_value::signed-integer-size(size)>>}
                        end
                      :error -> {nil, nil}
                    end
                  "string-float" ->
                    case (value |> String.trim() |> Float.parse()) do
                      {typed_value, _} ->
                        {typed_value, <<typed_value::float>>}
                      :error -> {nil, nil}
                    end
                  "string-ascii" ->
                    {value, value}
                  "hex-int" ->
                    bin = function("hex_2_binary", value)
                    size = bit_size(bin)
                    <<typed_value::signed-size(size)>> = bin
                    {typed_value, bin}
                  "hex-uint" ->
                    bin = function("hex_2_binary", value)
                    size = bit_size(bin)
                    <<typed_value::unsigned-size(size)>> = bin
                    {typed_value, bin}
                  "hex-float" ->
                    bin = function("hex_2_binary", value)
                    case byte_size(bin) do
                      4 ->
                        <<typed_value::float-size(32)>> = bin
                        {typed_value, bin}
                      8 ->
                        <<typed_value::float-size(64)>> = bin
                        {typed_value, bin}
                      _ ->
                        size = bit_size(bin)
                        <<typed_value::signed-size(size)>> = bin
                        {typed_value/1, <<typed_value::float>>}
                    end
                  _ ->
                    {nil, nil}
                end
              true ->
                {value, value}
            end
            function("save_tag_value", %{"value" => value, "valueType" => valueType, "typed_value" => typed_value, "typed_binary" => typed_binary, "path" => path})
            Log.info("function: transform: typed_value: #{inspect typed_value}")
            Log.info("function: transform: typed_binary: #{inspect typed_binary}")
            {typed_value, typed_binary}
      parse_condition:
        logic:
          $action: "elixir"
          value: |
            v |> Enum.filter(fn {key, _value} ->
              !String.starts_with?(key, "_")
            end) |> Enum.map(fn {key, value} ->
              cond do
                is_binary(value) -> {key, function("parse", %{"logic" => value, "allow_char" => true})}
                true -> {key, value}
              end
            end) |> Enum.into(%{})
      handleType:
        logic:
          $action: "elixir"
          value: |
            case v do
              %{"from" => "integer", "to" => "text"} -> inspect(v["value"])
              %{"from" => "number", "to" => "text"} -> inspect(v["value"])
              %{"from" => "text", "to" => "integer"} ->
                case Integer.parse(v["value"]) do
                  {val, _} -> val
                  _ -> v["value"]
                end
              %{"from" => "text", "to" => "number"} ->
                case Integer.parse(v["value"]) do
                  {val, _} -> val
                  _ -> v["value"]
                end
              %{"from" => "text", "to" => "float"} ->
                case Float.parse(v["value"]) do
                  {val, _} -> val
                  _ -> v["value"]
                end
              %{"from" => "text", "to" => "int"} ->
                case Integer.parse(v["value"]) do
                  {val, _} -> val
                  _ -> v["value"]
                end
              %{"from" => "text", "to" => "uint"} ->
                case Integer.parse(v["value"]) do
                  {val, _} -> val
                  _ -> v["value"]
                end
              _ -> v["value"]
            end
      parse:
        logic:
          $action: "elixir"
          value: |
            # in: logic:String
            # out: String
            require Integer
            logic = v["logic"] || ""
            logic |> String.split(["{", "}"]) |> Enum.with_index() |> Enum.map(fn {val, index} ->
              if (Integer.is_odd(index)) do
                arg = val |> String.split([",", "."]) |> Enum.map(fn x -> String.trim(x) end)
                case arg do
                  ["fn", "unique"] -> :rand.uniform(256)
                  ["action", category, group, device, tag, "binary"] -> get(["binary", "action", category, group, device, tag])
                  ["action", category, device, tag, "binary"] -> get(["binary", "action", category, "", device, tag])
                  ["action", category, group, device, tag, "raw"] -> get(["raw", "action", category, group, device, tag])
                  ["action", category, device, tag, "raw"] -> get(["raw", "action", category, "", device, tag])
                  ["action", category, group, device, tag] -> get(["value", "action", category, group, device, tag])
                  ["action", category, device, tag] -> get(["value", "action", category, "", device, tag])
                  [category, group, device, tag, "binary"] -> get(["binary", "tag", category, group, device, tag])
                  [category, device, tag, "binary"] -> get(["binary", "tag", category, "", device, tag])
                  [category, group, device, tag, "raw"] -> get(["raw", "tag", category, group, device, tag])
                  [category, device, tag, "raw"] -> get(["raw", "tag", category, "", device, tag])
                  [category, group, device, tag] -> get(["value", "tag", category, group, device, tag])
                  [category, device, tag] -> get(["value", "tag", category, "", device, tag])
                  _ -> ""
                end |> inspect()
              else
                val
              end
            end) |> Enum.join()
      parse_and_eval:
        logic:
          $action: "elixir"
          value: |
            # in: logic:String, allow_char:Boolean
            # out: Term
            parsed = function("parse", v)
            {ret, _} = if (v["allow_char"]) do
              Code.eval_string(parsed,[], __ENV__)
            else
              if String.match?(parsed, ~r/[a-zA-Z]/), do: {:error, "non arithmetic expression"}, else: Code.eval_string(parsed)
            end
            ret
      _DB/populate devices:
        logic:
          $action: "elixir"
          value: |
            devices = v["devices"] || []
            devices |> Enum.each(fn x ->
              properties = x["properties"] || %{}
              group = properties["group"] || ""
              category = properties["category"] || ""
              key = category <> "_" <> group <> "_" <> x["name"]
              query = """
              INSERT INTO devices (device_name, device_key)
              SELECT * FROM (SELECT '#{x["name"]}', '#{key}') AS tmp
              WHERE NOT EXISTS (
                SELECT * FROM devices
                WHERE device_key = '#{key}'
              )
              """
              Log.info("populate devices: query: " <> inspect(query))
              device_insert_result = instance(v["instance"], "query", query)
              Log.info("populate devices: device_insert_result: " <> inspect(device_insert_result))
              property_insert_result = case device_insert_result do
                {:ok, result} ->
                  num_rows = Map.get(result, :num_rows)
                  cond do
                    num_rows == 1 ->
                      last_insert_id = Map.get(result, :last_insert_id)
                      properties |> Enum.each(fn {x,y} ->
                        property_value = cond do
                          is_binary(y) -> y
                          is_map(y) -> Poison.encode!(y)
                          true -> inspect(y)
                        end
                        property_insert_query = """
                        INSERT INTO device_properties (device_id, property_name, property_value) VALUES (#{last_insert_id}, '#{x}', '#{property_value}')
                        ON DUPLICATE KEY UPDATE property_value = '#{property_value}'
                        """
                        property_insert_result = instance(v["instance"], "query", property_insert_query)
                      end)
                    num_rows == 0 ->
                      get_device_id_query = """
                      SELECT device_id FROM devices
                      INNER JOIN device_properties
                      USING (device_id) where device_name = '#{x["name"]}' and property_name = 'group' and property_value = '#{group}'
                      """
                      device_id_info = instance(v["instance"], "query", get_device_id_query)
                      case device_id_info do
                        {:ok, %Mariaex.Result{columns: _, connection_id: _, last_insert_id: _, num_rows: _, rows: [[device_id]]}} ->
                          properties |> Enum.each(fn {x,y} ->
                            property_value = cond do
                              is_binary(y) -> y
                              is_map(y) -> Poison.encode!(y)
                              true -> inspect(y)
                            end
                            property_insert_query = """
                            INSERT INTO device_properties (device_id, property_name, property_value) VALUES (#{device_id}, '#{x}', '#{property_value}')
                            ON DUPLICATE KEY UPDATE property_value = '#{property_value}'
                            """
                            instance(v["instance"], "query", property_insert_query)
                          end)
                        _ -> :ok
                      end
                    true -> :ok
                  end
                error -> Log.info("populate devices: error: " <> inspect(error))
              end
            end)
      _DB/populate tags:
        logic:
          $action: "elixir"
          value: |
            Log.info("populate tags: v: " <> inspect(v))
            tags = v["tags"] || []
            tags |> Enum.each(fn x ->
              Log.info("populate tags: x: " <> inspect(x))
              properties = x["properties"] || %{}
              group = properties["_group"] || ""
              device = properties["_device"] || ""
              category = properties["_category"] || ""
              key = category <> "_" <> group <> "_" <> device
              Log.info("populate tags: key: " <> inspect(key))
              get_device_id_query = """
              SELECT device_id FROM devices
              where device_key = '#{key}'
              """
              Log.info("populate tags: get_device_id_query: " <> inspect(get_device_id_query))
              device_id_info = instance(v["instance"], "query", get_device_id_query)
              Log.info("populate tags: device_id_info: " <> inspect(device_id_info))
              case device_id_info do
                {:ok, %Mariaex.Result{columns: _, connection_id: _, last_insert_id: _, num_rows: _, rows: [[device_id]]}} ->
                  query = """
                  INSERT INTO tag (tag_name, tag_value_type, device_id) VALUES ('#{x["name"]}', '#{x["value_type"]}', #{device_id})
                  ON DUPLICATE KEY UPDATE tag_value_type = '#{x["value_type"]}'
                  """
                  tag_insert_result = instance(v["instance"], "query", query)
                  property_insert_result = case tag_insert_result do
                    {:ok, result} ->
                      # num_rows = Map.get(result, :num_rows)
                      last_insert_id = Map.get(result, :last_insert_id)
                      cond do
                        last_insert_id != 0->
                          set(["tag_id", category, group, device, x["name"]], last_insert_id)
                          properties |> Enum.each(fn {x,y} ->
                            property_value = cond do
                              is_binary(y) -> y
                              is_map(y) -> Poison.encode!(y)
                              true -> inspect(y)
                            end
                            property_insert_query = """
                            INSERT INTO tag_properties (tag_id, property_name, property_value) VALUES (#{last_insert_id}, '#{x}', '#{property_value}')
                            ON DUPLICATE KEY UPDATE property_value = '#{property_value}'
                            """
                            instance(v["instance"], "query", property_insert_query)
                          end)
                        last_insert_id == 0 ->
                          get_tag_id_query = """
                          SELECT tag_id FROM tag
                          where tag_name = '#{x["name"]}' and device_id = #{device_id}
                          """
                          tag_id_info = instance(v["instance"], "query", get_tag_id_query)
                          case tag_id_info do
                            {:ok, %Mariaex.Result{columns: _, connection_id: _, last_insert_id: _, num_rows: _, rows: [[tag_id]]}} ->
                              set(["tag_id", category, group, device, x["name"]], tag_id)
                              properties |> Enum.each(fn {x,y} ->
                                property_value = cond do
                                  is_binary(y) -> y
                                  is_map(y) -> Poison.encode!(y)
                                  true -> inspect(y)
                                end
                                property_insert_query = """
                                INSERT INTO tag_properties (tag_id, property_name, property_value) VALUES (#{tag_id}, '#{x}', '#{property_value}')
                                ON DUPLICATE KEY UPDATE property_value = '#{property_value}'
                                """
                                instance(v["instance"], "query", property_insert_query)
                              end)
                            _ -> :ok
                          end
                        true -> :ok
                      end
                    _ -> :ok
                  end
                _ -> :ok
              end
            end)
      _DB/setup tables:
        logic:
          $action: "elixir"
          value: |
            ["""
            CREATE TABLE IF NOT EXISTS devices(
              device_id             INT           AUTO_INCREMENT PRIMARY KEY,
              device_key            VARCHAR(255)  NOT NULL,
              device_name           VARCHAR(255)  NOT NULL,
              created_at            TIMESTAMP     DEFAULT CURRENT_TIMESTAMP
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS device_properties(
              device_id             INT           NOT NULL,
              property_name         VARCHAR(255)  NOT NULL,
              property_value        VARCHAR(512)  DEFAULT '',
              UNIQUE KEY `key` (`device_id`,`property_name`)
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS tag(
              tag_id                INT           AUTO_INCREMENT PRIMARY KEY,
              device_id             INT           NOT NULL,
              tag_name              VARCHAR(255)  NOT NULL,
              tag_value_type        VARCHAR(16)   DEFAULT 'string',
              tag_value             TEXT,
              UNIQUE KEY `key` (`device_id`,`tag_name`)
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS tag_properties(
              tag_id                INT           NOT NULL,
              property_name         VARCHAR(255)  NOT NULL,
              property_value_type   VARCHAR(16)   DEFAULT 'string',
              property_value        VARCHAR(512)  DEFAULT '',
              UNIQUE KEY `key` (`tag_id`,`property_name`)
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS action_history(
              action_history_id        INT           AUTO_INCREMENT PRIMARY KEY,
              created_at            TIMESTAMP     DEFAULT CURRENT_TIMESTAMP,
              value                 TEXT          NOT NULL
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS tag_history(
              tag_history_id        INT           AUTO_INCREMENT PRIMARY KEY,
              tag_id                INT           NOT NULL,
              created_at            TIMESTAMP     DEFAULT CURRENT_TIMESTAMP,
              value                 TEXT          NOT NULL
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS clients(
              client_id             INT           AUTO_INCREMENT PRIMARY KEY,
              client_name           VARCHAR(255)  NOT NULL,
              created_at            TIMESTAMP     DEFAULT CURRENT_TIMESTAMP
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS client_properties(
              client_id             INT           NOT NULL,
              property_name         VARCHAR(255)  NOT NULL,
              property_value        VARCHAR(512)  DEFAULT '',
              UNIQUE KEY `key` (`client_id`,`property_name`)
            );
            """] |> Enum.map(fn x ->
              instance(v["instance"], "query", x)
            end)
      map:
        logic:
          $action: "elixir"
          value: |
            Log.info("map: #{inspect v}")
            mappings = get("mappings") || []
            Log.info("map: mappings: #{inspect mappings}")
            mappings |> Enum.find(fn x ->
              v["key"] == {x["from"]["name"], x["from"]["device"], x["from"]["group"]}
            end) |> case do
              nil ->
                Log.info("map: no matching mapping")
                :ok
              mapping ->
                Log.info("map: mapping: #{inspect mapping}")
                from = mapping["from"] || %{}
                to = mapping["to"] || %{}
                tags = get("tags") || []
                key = {to["name"], to["device"], to["group"]}
                tags |> Enum.find(fn x ->
                  key == {x["name"], x["properties"]["_device"], x["properties"]["_group"]}
                end) |> case do
                  nil -> :ok
                  tag ->
                    new_condition = function("parse_condition", tag["properties"]["_condition"])
                    arg = tag["properties"] |> Map.put("value", v["value"]) |> Map.put("_condition", new_condition)
                    case to["action"] do
                      "read" -> instance(to["group"] <>"/" <> to["device"], "read_tag", arg)
                      "write" -> instance(to["group"] <>"/" <> to["device"], "write_tag", arg)
                      _ -> instance(to["group"] <>"/" <> to["device"], "read_tag", arg)
                    end
                end
            end
    type: "string"
  service:
    default: |
      http client:
        function:
          get:
            data:
              - "url"
            logic:
              $action: "elixir"
              value: |
                Log.info("http client: " <> inspect v)
                req = get()
                Log.info("http client: req: " <> inspect req)
                # Service.Http.get(v["url"])
          write_tag:
            logic:
              $action: "elixir"
              value: |
                Log.info("http client: write: v: " <> inspect v)
                data = get()
                Log.info("http client: write: data: " <> inspect data)
                # Check data["url"] and replace all variable from v
                url = data["url"] |> Utils.Data.string_var_replace("{", "}", v)
                Log.info("http client: write: url: " <> inspect url)
                value = cond do
                  is_binary(v["value"]) -> v["value"]
                  true -> inspect v["value"]
                end
                Service.Http.put(url, value)
          read_tag:
            logic:
              $action: "elixir"
              value: |
                Log.info("http client: read: v: " <> inspect v)
                data = get()
                Log.info("http client: read: data: " <> inspect data)
                # Check data["url"] and replace all variable from v
                url = data["url"] |> Utils.Data.string_var_replace("{", "}", v)
                Log.info("http client: url: " <> inspect url)
                Service.Http.get(url)
    type: "string"
description: "EdgeHub Engine Project"
function:
  clean up:
    logic:
      $action: "elixir"
      value: |
        project = "edgehub_solution_default"
        delete_conf([], project)
        function("instance stop all", %{"project" => project})
        compile(project)
        set_version(project)
  compile:
    logic:
      $action: "elixir"
      value: |
        # Initialize
        set("edgehub_db_list", [])
        project = "edgehub_solution_default"
        config = get("config") || %{}
        devices = config["devices"] || []
        protocols = config["protocols"] || []
        interactor_config = %{}
        config_string = cond do
          is_map(config) -> Poison.encode!(config)
          is_binary(config) -> config
          true -> ""
        end

        service_builtin_map = case get_conf(["service"], project: "edgehub") do
          {:ok, service_builtin} -> service_builtin
          _ -> %{}
        end

        # Create service
        service = get("service") |> Yaml.Decoder.read_from_string!() |> Map.merge(service_builtin_map)
        custom_service = function("compile service", project: project, protocols: protocols)
        Log.info("compile: custom_service: #{inspect custom_service}")
        service = service |> Map.merge(custom_service)

        # Create instances
        timer_instances = function("compile tag", project: project, tag_map: config["tags"], interactor_config: interactor_config)
        device_instances = function("compile device", project: project, devices: devices, interactor_config: interactor_config, custom_service: custom_service |> Enum.map(fn {k,v} -> k end))
        instances = device_instances |> Map.merge(timer_instances)

        # Create Data
        stat_device_data = device_instances |> Map.keys() |> Enum.reduce(%{}, fn x, acc ->
          %{
            x => %{
              "sent_count" => 0,
              "received_count" => 0,
              "error_count" => 0,
              "continuous_error_count" => 0
            } |> Map.merge(acc)
          }
        end)

        edgehub_db_list = get("edgehub_db_list")
        Log.info("compile: edgehub_db_list: #{inspect edgehub_db_list}")

        data = %{
          "mappings" => %{
            "default" => config["mappings"]
          },
          "tags" => %{
            "default" => config["tags"]
          },
          "actions" => %{
            "default" => config["actions"]
          },
          "config" => %{
            "default" => config_string
          },
          "edgehub_db_list" => %{
            "default" => edgehub_db_list
          },
          "stat" => %{
            "device" => stat_device_data
          }
        }

        # Create interactor configuration
        interactor_config =
          %{"instance" => instances}
          |> Map.put("data", data)
          |> Map.put("service", service)
          |> Map.put("function", get("function") |> Yaml.Decoder.read_from_string!())

        # Configure and compile
        Log.info("compile: interactor_config: #{inspect(interactor_config)}")
        # delete_conf([], project: project)
        clear([], project: project)
        function("instance stop all", %{"project" => project})
        interactor_config |> put_conf([], project: project)
        :timer.sleep(10)
        compile(project)
        set_version(project)
        function("instance start all", %{"project" => project})
  compile device:
    logic:
      $action: "elixir"
      value: |
        Log.info("compile device: #{inspect(v)}")
        project = v[:project] || "edgehub_solution_default"
        devices = v[:devices] || []
        custom_service = v[:custom_service] || []
        global_services = case get_conf(["service"], project: "__GLOBAL__") do
          {:ok, nil} -> []
          {:ok, config} -> config |> Map.keys()
          _ -> []
        end
        local_services = case get_conf(["service"], project: "edgehub") do
          {:ok, nil} -> []
          {:ok, config} -> config |> Map.keys()
          _ -> []
        end

        services = Interactor.Instance.built_in_services() ++ global_services ++ local_services ++ custom_service
        Log.info("compile device: services: #{inspect services}")
        instance_configuration =
          devices
          |> Enum.reduce(%{}, fn x, acc ->
            Log.info("compile device: x: #{inspect x}")
            properties = x["properties"] || %{}
            group = properties["group"] || ""
            key = group <> "/" <> x["name"]
            communication = properties["communication"] || %{}
            event = %{
              "write" => %{
                "$action" => "elixir",
                "value" => """
                  Log.info("write: triggered: #{key}: \#{inspect v}")
                  Log.info("write: triggered: randomness: #{inspect :rand.uniform(1000)}")
                  path = v["path"]
                  Log.info("write: triggered: #{key}: path: \#{inspect path}")
                  value = v["value"]
                  Log.info("write: triggered: #{key}: value: \#{inspect value}")
                  tags = get("tags") || []
                  if (path) do
                    Log.info("write: triggered: #{key}: object write:")
                    tags |> Enum.filter(fn x ->
                      Log.info("write: triggered: #{key}: x: \#{inspect x}")
                      group = x["properties"]["_group"] || ""
                      x_path = ["tag", x["properties"]["_category"], group, x["properties"]["_device"], x["name"]]
                      Log.info("write: triggered: #{key}: x_path: \#{inspect x_path}")
                      x_path == path
                    end)
                  else
                    tags |> Enum.filter(fn x ->
                      group = x["properties"]["_group"] || ""
                      (x["idFields"] == v["idFields"]) && (#{inspect group} == group) && (x["properties"]["_device"] == #{inspect x["name"]})
                    end)
                  end |> Enum.each(fn y -> # y: tags to be processed
                    Log.info("write: triggered: #{key}: y: \#{inspect y}")
                    case y["properties"]["_category"] do
                      "virtual" ->
                        Log.info("write: triggered: #{key}: virtual:")
                        function("transform", %{"value" => value["value"], "type" => y["properties"]["_condition"]["valueType"], "path" => path})
                      "device" ->
                        Log.info("write: triggered: #{key}: device:")
                        tag = tags |> Enum.find(fn z ->
                          Log.info("write: triggered: #{key}: z: \#{inspect z}")
                          (z["properties"]["_group"] == y["properties"]["_condition"]["group"]) && (z["properties"]["_device"] == y["properties"]["_condition"]["device"]) && (z["name"] == y["properties"]["_condition"]["tag"])
                        end)
                        Log.info("write: triggered: #{key}: tag: \#{inspect tag}")
                        instance_name = if (tag["properties"]["communication"]["serial"]) do
                          "Serial_Port_" <> tag["properties"]["communication"]["data"]["port"]
                        else
                          "\#{y[\"properties\"][\"_condition\"][\"group\"]}/\#{y[\"properties\"][\"_condition\"][\"device\"]}"
                        end
                        # instance_name = "\#{y[\"properties\"][\"_condition\"][\"group\"]}/\#{y[\"properties\"][\"_condition\"][\"device\"]}"
                        Log.info("write: triggered: #{key}: instance_name: \#{inspect instance_name}")
                        new_condition = function("parse_condition", tag["properties"]["_condition"])
                        result = instance(instance_name, "write_tag", %{"properties" => tag["properties"] |> Map.put("_condition", new_condition), "value" => v["value"]})
                        Log.info("write: triggered: #{key}: result: \#{inspect result}")
                    end
                  end)
                """
              }
            }
            database_connected_event = %{
              "connected" => %{
                "$action" => "elixir",
                "value" => """
                  Log.info("_DB: connected: \#{inspect v}")
                  function("_DB/setup tables", %{"instance" => #{inspect key}})
                  config_string = get("config") || "{}"
                  config = cond do
                    is_binary(config_string) -> Poison.decode!(config_string)
                    true -> %{}
                  end
                  devices = config["devices"] || []
                  tags = config["tags"] || []
                  function("_DB/populate devices", %{"devices" => devices, "instance" => #{inspect key}})
                  function("_DB/populate tags", %{"tags" => tags, "instance" => #{inspect key}})
                """
              }
            }
            http_server_received_event = %{
              "received" => %{
                "$action" => "elixir",
                "value" => """
                  Log.info("EdgeHub HTTP Server: \#{inspect v}")
                  [_|paths] = v["path"] |> String.split("/")
                  path = case paths do
                    [type, "virtual", device, tag] -> [type, "virtual", "", device, tag]
                    [type, "database", device, tag] -> [type, "database", "", device, tag]
                    _ -> paths
                  end
                  case v["method"] do
                    "PUT" ->
                      value = case Poison.decode(v["body"]) do
                        {:error, %Poison.ParseError{}} -> v["body"]
                        {:ok, map} -> map
                      end
                      set(["value"] ++ path, value)
                      %{"result" => "success"}
                    _ -> %{"result" => "success", "value" => get(["value"] ++ path)}
                  end |> Poison.encode!()
                """
              }
            }
            cond do
              communication["serial"] ->
                Log.info("compile device: serial device: " <> inspect(key))
                # Check if there is existing instance with same port id
                port_name = "Serial_Port_" <> communication["data"]["port"]
                if (acc |> Map.keys() |> Enum.member?(port_name)) do
                  Log.info("compile device: serial device: exists: ")
                  acc
                else
                  Log.info("compile device: serial device: new: ")
                  acc
                  |> Map.put(port_name, %{
                    "use" => communication["service"],
                    "data" => communication["data"],
                    "event" => event
                  })
                end
              Enum.member?(services, communication["service"]) ->
                event = cond do
                  ((communication["service"] == "mariadb") && (communication["data"]["type"] == "edgehub")) ->
                    edgehub_db_list = get("edgehub_db_list") || []
                    set("edgehub_db_list", edgehub_db_list ++ [key], flatten: true)
                    event |> Map.merge(database_connected_event)
                  (communication["service"] == "http server") ->
                    event |> Map.merge(http_server_received_event)
                  true ->
                    event
                end
                acc
                |> Map.put(key, %{
                  "use" => communication["service"],
                  "data" => communication["data"],
                  "event" => event
                })
              true ->
                acc
            end
          end)

        Log.info("compile device: instance_configuration: #{inspect(instance_configuration)}")
        instance_configuration
  compile service:
    logic:
      $action: "elixir"
      value: |
        Log.info("compile service: #{inspect(v)}")
        project = v[:project] || "edgehub_solution_default"
        protocols = v[:protocols] || []

        service_configuration =
          protocols
          |> Enum.filter(fn {protocol_name, protocol_config} -> (protocol_config["builtIn"] != true) && (protocol_config["service"] != nil) end)
          |> Enum.map(fn {protocol_name, protocol_config} ->
            Log.info("compile service: custom: protocol_name: " <> protocol_name)
            Log.info("compile service: custom: protocol_config: " <> inspect(protocol_config))
            connectionInfo = protocol_config["connectionInfo"] || []
            Log.info("compile service: custom: connectionInfo: " <> inspect(connectionInfo))

            # Configure Data
            data = connectionInfo |> Enum.map(fn x ->
              {x["key"], %{
                  "input" => true,
                  "required" => true,
                  "type" => x["valueType"] || "string",
                  "default" => x["default"] || ""
                }
              }
            end) |> Enum.into(%{})
            Log.info("compile service: custom: data: " <> inspect(data))

            # Configure Function
            read_tag_map_string = case protocol_config["service"] do
              "port" ->
                (protocol_config["tagInfo"] |> Enum.reduce("tagInfo = %{\r\n", fn info, acc ->
                  acc <>
                  """
                    "#{info["key"]}" => v["_condition"]["#{info["key"]}"],
                  """
                  <> "\r\n"
                end)) <>
                """
                }
                Log.info("#{protocol_name}: function: read_tag: tagInfo: " <> inspect(tagInfo))
                map = %{"command" => "read_tag", "tagInfo" => tagInfo}
                Log.info("#{protocol_name}: function: read_tag: map: " <> inspect(map))
                data = case Poison.encode(map) do
                  {:ok, d} -> d <> "\n"
                  error -> "{}\n"
                end
                Log.info("#{protocol_name}: function: read_tag: data: " <> inspect(data))
                """
              _ ->
                (protocol_config["readrequestfields"] |> Enum.reduce("map = %{\r\n", fn x, acc ->
                  Log.info("compile service: custom: x: #{inspect(x)}")
                  field_string = case x["sourceType"] do
                    "set" ->
                      """
                        "#{x["name"]}" => function("handleType", %{
                          "from" => "text",
                          "to" => "#{x["type"]}",
                          "value" => function("parse", %{
                            "logic" => "#{x["set"]}",
                            "allow_char" => true
                          })
                        }),
                      """
                    "dynamic" ->
                      case x["source"] do
                        "connectionInfo" ->
                          conn_info = connectionInfo |> Enum.find(fn info -> info["key"] == x["info"] end) || {}
                          from = conn_info["valueType"] || "text"
                          """
                            "#{x["name"]}" => function("handleType", %{
                              "from" => "#{from}",
                              "to" => "#{x["type"]}",
                              "value" => get("#{x["info"]}")
                            }),
                          """
                        "tagInfo" ->
                          tagInfo = protocol_config["tagInfo"] || []
                          tag_info = tagInfo |> Enum.find(fn info -> info["key"] == x["info"] end) || {}
                          from = tag_info["valueType"] || "text"
                          """
                            "#{x["name"]}" => function("handleType", %{
                              "from" => "#{from}",
                              "to" => "#{x["type"]}",
                              "value" => v["_condition"]["#{x["info"]}"]
                            }),
                          """
                        _ -> ""
                      end
                    _ -> ""
                  end
                  acc <> field_string <> "\r\n"
                end)) <>
                """
                }
                encoded = encode(map, "#{protocol_config["readrequest"]}")
                Log.info("#{protocol_name}: function: read_tag: encoded: " <> inspect(encoded))
                data = encoded |> Map.get(:result)
                Log.info("#{protocol_name}: function: read_tag: data: " <> inspect(data))
                """
            end
            read_tag = """
            Log.info("#{protocol_name}: function: read_tag: v: " <> inspect(v))
            Log.info("#{protocol_name}: function: read_tag: randomness: #{inspect :rand.uniform(1000)}")
            """ <> read_tag_map_string <> case protocol_config["service"] do
              "tcp" -> "result = Service.Tcp.send_and_recv(get(\"address\"), get(\"port\"), data) "
              "port" ->
                """
                send_id = :rand.uniform(1_000_000)
                instance("custom", "send", %{"data" => data, "id" => send_id})
                Log.info("#{protocol_name}: function: read_tag: send_id: " <> inspect(send_id))
                result = Enum.find_value(1..20000, <<>>, fn x ->
                  :timer.sleep(1)
                  received = instance("custom", "check received", send_id)
                  if (received == ""), do: false, else: {:port, received}
                end)
                """
              _ -> "result = instance(\"custom\", \"send\", data) "
            end <> """
            |> case do
              {:ok, ret} ->
                decoded = decode(ret, "response")
                {:ok, decoded |> Map.get(:result) |> Map.get("#{protocol_config["readresponsefield"]}")}
              {:port, ret} ->
                {:ok, Poison.decode!(ret) |> Map.get("value")}
              error ->
                {:error, error}
            end
            Log.info("#{protocol_name}: function: read_tag: result: " <> inspect(result))
            result
            """
            Log.info("compile service: custom: read_tag: \r\n" <> read_tag)
            function = %{
              "read_tag" => %{
                "logic" => %{
                  "$action" => "elixir",
                  "value" => read_tag
                }
              }
            }
            Log.info("compile service: custom: function: " <> inspect(function))

            use = case protocol_config["service"] do
              "tcp" -> "tcp client"
              "serial" -> "serial"
              "port" -> "port"
              other -> other
            end
            Log.info("compile service: custom: use: " <> inspect(use))


            # Configure Model
            config = protocol_config["config"] || %{}
            models = config["model"] || %{}
            Log.info("compile service: custom: models: \r\n" <> inspect(models))

            model = models |> Enum.reduce([], fn {model_name, model_config}, acc ->
              Log.info("compile service: model_name: #{inspect(model_name)}")
              Log.info("compile service: model_config: #{inspect(model_config)}")
              fields = model_config["fields"] || []
              case fields do
                [] -> acc
                _ ->
                  new_config = {model_name, %{
                    "$parser" => "binary",
                    "rand" => :rand.uniform(1000),
                    "fields" => fields |> Enum.map(fn field ->
                      Log.info("compile service: field: #{inspect(field)}")
                      size = case Integer.parse(field["size"]) do
                        {x, _} -> x
                        :error ->
                          %{
                            "$action" => "elixir",
                            "value" => "v[" <> inspect(field["size"]) <> "]"
                          }
                      end
                      %Elixir.Compiler.Model.Binary.Struct.Field{
                        name: field["name"],
                        size: size,
                        type: field["type"],
                        options: field["options"]
                      }
                    end)
                  }}
                  Log.info("compile service: new_config: #{inspect(new_config)}")
                  acc ++ [new_config]
              end
            end) |> Enum.into(%{})
            Log.info("compile service: model: #{inspect(model)}")

            instance_data = case protocol_config["service"] do
              "tcp" -> ["address", "port"]
              "serial" -> ["port", "speed", "data_bits", "stop_bits", "parity", "framing", "framing_separator", "framing_timeout", "models"]
              "port" -> ["executable", "args", "packet", "type"]
            end |> Enum.map(fn key ->
              {key, %{
                "$action" => "elixir",
                "value" => "get(\"#{key}\")"
              }}
            end) |> Enum.into(%{})
            Log.info("compile service: instance_data: #{inspect(instance_data)}")

            instance = %{
              "custom" => %{
                "data" => instance_data,
                "use" => use
              }
            }
            Log.info("compile service: instance: #{inspect(instance)}")

            # Configure service
            service_config = %{
              "data" => data,
              "function" => function,
              "model" => model,
              "instance" => instance
            }
            {protocol_name, service_config}
          end) |> Enum.into(%{})

        Log.info("compile service: service_configuration: #{inspect(service_configuration)}")
        service_configuration
  compile tag:
    logic:
      $action: "elixir"
      value: |
        Log.info("compile tag: #{inspect(v)}")
        tag_map = v[:tag_map] || %{}

        timers =
          tag_map
          |> Enum.reduce(%{}, fn value, acc ->
            Log.info("compile tag: tag: #{inspect value["name"]}")
            if (value["properties"]["_condition"]["_interval"]) do
              category = if value["properties"]["_category"], do: value["properties"]["_category"], else: ""
              group = if value["properties"]["_group"], do: value["properties"]["_group"], else: ""
              device = if value["properties"]["_device"], do: value["properties"]["_device"], else: ""
              instance_name = "__timer_" <> category <> "_" <> group <> "_" <> device <> "_" <> inspect(value["properties"]["_condition"]["_interval"]) <> "ms"
              if acc[instance_name] do
                tags = acc[instance_name]["data"]["tags"] ++ [value]
                acc |> Interactor.Object.put_in([instance_name, "data", "tags"], tags)
              else
                acc |> Map.put(instance_name, %{
                  "use" => "timer",
                  "data" => %{
                    "priority" => "low",
                    "interval" => value["properties"]["_condition"]["_interval"],
                    "tags" => [value],
                    "value" => %{}
                  },
                  "event" => %{
                    "execute" => %{
                      "$action" => "elixir",
                      "value" => """
        Log.info("timer: #{instance_name}: triggered: \#{inspect v}")
        Log.info("timer: #{instance_name}: randomness: #{inspect :rand.uniform(1000)}")
        if (v["count"] > 1) do
          tags = v["data"][:config]["tags"] || []
          result = tags |> Enum.map(fn x ->
            try do
              Log.info("timer: #{instance_name}: processing tag: \#{inspect x}")
              category = x["properties"]["_category"] || ""
              group = x["properties"]["_group"]
              device = x["properties"]["_device"] || ""
              condition = x["properties"]["_condition"] || %{}
              case category do
                "virtual" ->
                  ret = function("parse_and_eval", %{"logic" => x["properties"]["_condition"]["logic"], "allow_char" => true})
                  {typed_value, typed_binary} = function("transform", %{"value" => ret, "type" => x["properties"]["_condition"]["valueType"], "path" => ["tag", category, group || "", device, x["name"]]})
                  tags = get("tags") || []
                  server_tags = tags |> Enum.filter(fn y ->
                    (y["properties"]["_condition"]["category"] === "virtual") && (y["properties"]["_condition"]["device"] === "Virtual") && (y["properties"]["_condition"]["tag"] === x["name"])
                  end) |> Enum.each(fn z ->
                    instance("\#{z[\"properties\"][\"_group\"]}/\#{z[\"properties\"][\"_device\"]}", "write_mem", %{"tag" => z, "bin" => typed_binary, "value" => typed_value})
                  end)
                  action_results = function("execute_actions", %{"tag" => x, "value" => typed_value})
                  db_result = function("db_put", %{"tag" => x, "value" => ret})
                  Log.info("timer: #{instance_name}: virtual: action_results: \#{inspect action_results}")
                  ret
                _ ->
                  Log.info("timer: #{instance_name}: instance name: \#{x[\"properties\"][\"_group\"]}/\#{x[\"properties\"][\"_device\"]}")
                  target_instance = if (x["properties"]["communication"]["serial"]) do
                    "Serial_Port_" <> x["properties"]["communication"]["data"]["port"]
                  else
                    "\#{x[\"properties\"][\"_group\"]}/\#{x[\"properties\"][\"_device\"]}"
                  end
                  count(["stat",target_instance,"sent_count"], 1)
                  new_condition = function("parse_condition", condition)
                  case instance(target_instance, "read_tag", x["properties"] |> Map.put("_name", x["name"]) |> Map.put("_condition", new_condition)) do
                    {:ok, response} ->
                      count(["stat",target_instance,"received_count"], 1)
                      set(["stat",target_instance,"continuous_error_count"], 0)
                      {typed_value, typed_binary} = function("transform", %{"value" => response, "type" => x["properties"]["_condition"]["valueType"], "path" => ["tag", category, group || "", device, x["name"]]})
                      tags = get("tags") || []
                      server_tags = tags |> Enum.filter(fn y ->
                        (y["properties"]["_condition"]["group"] === group) && (y["properties"]["_condition"]["device"] === device) && (y["properties"]["_condition"]["tag"] === x["name"])
                      end) |> Enum.each(fn z ->
                        instance("\#{z[\"properties\"][\"_group\"]}/\#{z[\"properties\"][\"_device\"]}", "write_mem", %{"tag" => z, "bin" => typed_binary, "value" => typed_value})
                      end)
                      action_results = function("execute_actions", %{"tag" => x, "value" => typed_value})
                      db_result = function("db_put", %{"tag" => x, "value" => typed_value})
                      response
                    error ->
                      Log.warn("#{instance_name}: error: \#{inspect error}")
                      count(["stat",target_instance,"error_count"], 1)
                      count(["stat",target_instance,"continuous_error_count"], 1)
                      ""
                  end
              end
            rescue
              e -> Log.error("EdgeHub: Action: Error: read_tag: " <> inspect e)
            end
          end)
          Log.info("#{instance_name}: result: \#{inspect result}")
        end
                      """
                    }
                  }
                })
              end
            else
              acc
            end
          end)
        Log.info("timers: #{inspect(timers)}")
        timers
  imap:
    logic:
      $action: "elixir"
      value: |
        Utils.Transform.map(get(["imap"]), get(["config"]))
  instance start:
    logic:
      $action: "elixir"
      value: |
        Log.info("instance start: #{inspect(v)}")
        Interactor.Instance.start(v["path"] |> Enum.at(-1), Execution.State.new(v["project"]))
  instance start all:
    logic:
      $action: "elixir"
      value: |
        Log.info("instance start all: #{inspect(v)}")
        Interactor.Instance.start(:all, Execution.State.new(v["project"]))
  instance stop:
    logic:
      $action: "elixir"
      value: |
        Log.info("instance stop: #{inspect(v)}")
        Interactor.Instance.stop(v["path"] |> Enum.at(-1), Execution.State.new(v["project"]))
  instance stop all:
    logic:
      $action: "elixir"
      value: |
        Log.info("instance stop all: #{inspect(v)}")
        Interactor.Instance.stop(:all, Execution.State.new(v["project"]))
  read_file:
    logic:
      $action: "elixir"
      value: |
        File.read!(get("base_dir") <> v["dir"])
  respond:
    logic:
      $action: "elixir"
      value: |
        cond do
          is_binary(v) ->
            %{"headers" => %{"Content-Type" => "application/json"}}
            |> Map.put("body", v)
          is_map(v) ->
            case v do
              %{"headers" => headers} ->
                h = headers |> Map.put("Content-Type", "application/json")
                v |> Map.put("headers", h)
              %{:headers => headers} ->
                h = headers |> Enum.into(%{}) |> Map.put("Content-Type", "application/json")
                v |> Map.put("headers", h)
              _ ->
                Log.info("respond: map: any: #{inspect v}")
                %{"headers" => %{"Content-Type" => "application/json"}}
                |> Map.put("body", v |> ISON.encode() |> Poison.encode!())
            end
          true ->
            %{"headers" => %{"Content-Type" => "application/json"}}
            |> Map.put("body", v)
        end
  save config:
    logic:
      $action: "elixir"
      value: |
        config = get("config")
        Utils.Encryption.write("edgehub/client0.conf", "default" |> Base.encode64(), "Mr.Choi", config)
instance:
  api:
    data:
      port: 1290
    event:
      received:
        $action: "match"
        matches:
          - do:
              $action: "elixir"
              value: |
                resp = %{"status" => "success", "result" => get("admin")} |> Poison.encode!()
                function("respond", resp)
            model:
              $ref: "/api/admin/get"
          - do:
              $action: "elixir"
              value: |
                Log.info("/api/admin/set: #{inspect(v)}")
                set("admin", v["body"], flatten: true)
                resp = %{"status" => "success", "result" => "success"}
                function("respond", resp)
            model:
              $ref: "/api/admin/set"
          - do:
              $action: "elixir"
              value: |
                # Log.info("/api/add_first_user: #{inspect(v)}")

                resp = if(Table.Admin.get_all('user') == []) do
                  Utils.User.add(v["body"]["username"], v["body"]["password"])
                  %{"status" => "success", "result" => "User added"}
                else
                  %{"status" => "error", "result" => "Cannot add first user when users already exist"}
                end
                |> Poison.encode!()
                function("respond", resp)
            model:
              $ref: "/api/add_first_user"
          - do:
              $action: "elixir"
              value: |
                result = Table.Admin.get_all('user') == []
                resp = %{"status" => "success", "result" => result} |> Poison.encode!()
                function("respond", resp)
            model:
              $ref: "/api/is_first_user"
          - do:
              $action: "elixir"
              value: |
                resp = if(Utils.User.authenticate(v["body"]["username"], v["body"]["password"])) do
                  cookie = GenServer.call(UI.Cookies, {:add, v["body"]["username"]})
                  req = UI.Utils.set_header("set-cookie", [cookie |> UI.Utils.add_cookie_suffix()], v)

                  req =
                    %{"headers" => %{"set-cookie" => [cookie |> UI.Utils.add_cookie_suffix()]}}
                    |> Map.put("body", %{"status" => "success", "result" => v["body"]["username"]})

                  req
                else
                  %{"status" => "error", "result" => "invalid"}
                end
                function("respond", resp)
            model:
              $ref: "/api/login"
          - do:
              $action: "elixir"
              value: |
                cookie = GenServer.call(UI.Cookies, {:delete, v["headers"]["cookie"]})

                req =
                  %{"headers" => %{"set-cookie" => [cookie |> UI.Utils.add_cookie_suffix()]}}
                  |> Map.put("body", %{"status" => "success", "result" => "logged out"})
            model:
              $ref: "/api/logout"
          - do:
              $action: "elixir"
              value: |
                set("config", get("defaultConfig"), flatten: true)
                body = %{"status" => "success", "result" => get("config")} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/config/clear"
          - do:
              $action: "elixir"
              value: |
                body = %{"status" => "success", "result" => get("defaultConfig")} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/config/default"
          - do:
              $action: "elixir"
              value: |
                Log.info("config/get: " <> inspect(v))
                Log.info("config/get: config: " <> inspect(get("config")))
                body = %{"status" => "success", "result" => get("config")} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/config/get"
          - do:
              $action: "elixir"
              value: |
                body = cond do
                  is_map(v["body"]) ->
                    set("config", v["body"], flatten: true)
                    # function("compile")
                    %{"status" => "success", "result" => "success"} |> Poison.encode!()
                  true ->
                    %{"status" => "error", "result" => "Incorrect configuration structure"} |> Poison.encode!()
                end
                function("respond", body)
            model:
              $ref: "/api/config/set"
          - do:
              $action: "elixir"
              value: |
                # Log.info("/api/log/get: #{inspect(v)}")
                logs = Interactor.Log.get(v["body"])

                body = %{"status" => "success", "result" => %{"logs" => logs}} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/log/get"
          - do:
              $action: "elixir"
              value: |
                # Log.info("/api/log/clear: #{inspect(v)}")
                Interactor.Log.clear_logs()

                function("respond", %{"status" => "success", "result" => %{}})
            model:
              $ref: "/api/log/clear"
          - do:
              $action: "elixir"
              value: |
                license =
                  case(Table.System.get_value("license")) do
                    :no_record ->
                      %{
                        "active_rules" => %{"usage_interval" => "86400", "usage_max" => "1"},
                        "type_info" => %{"license_type_name" => "Trial"},
                        "license_info" => %{"license_expiry" => 0}
                      }

                    license ->
                      license
                  end

                result = %{
                  "version" =>
                    case(:application.get_key(:interactor, :vsn)) do
                      :undefined ->
                        "0.0.0"

                      {:ok, version} ->
                        version |> to_string()
                    end,
                  "license_type" => license["type_info"]["license_type_name"],
                  "license_expiration" => license["license_info"]["license_expiry"],
                  "license_rules" => license["active_rules"]
                }

                body = %{"status" => "success", "result" => result} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/get_interactor_info"
          - do:
              $action: "elixir"
              value: |
                {:ok, hostname} = :inet.gethostname()
                os_type = :os.type()
                os = ""
                interfaces = []

                cpu_model =
                  case(os_type) do
                    {_, :darwin} ->
                      :os.cmd('sysctl -a | grep machdep.cpu.brand_string')
                      |> to_string()
                      |> String.split("machdep.cpu.brand_string: ")
                      |> Enum.at(1)

                      os = "MacOS"

                      interfaces =
                        :os.cmd('ifconfig | grep "inet "')
                        |> to_string()
                        |> String.split(~r"\\\\\\\\\\\\\\\\R")
                        |> Enum.map(fn x -> String.split(x) end)

                    _ ->
                      ""
                  end

                system_stat =
                  Map.new()
                  |> Map.put("app_memory", :erlang.memory() |> Enum.into(%{}))
                  |> Map.put("app_processes", length(:erlang.processes()))
                  |> Map.put("app_active_tasks", :erlang.statistics(:total_active_tasks))
                  |> Map.put("architecture", :erlang.system_info(:system_architecture) |> to_string())
                  |> Map.put("cores", :erlang.system_info(:logical_processors))
                  |> Map.put("cpu", cpu_model)
                  |> Map.put("hostname", hostname |> to_string())
                  |> Map.put("interfaces", interfaces)
                  |> Map.put("os_type", os)
                  |> Map.put("os_version", :os.version() |> Tuple.to_list() |> Enum.join("."))
                  # |> Map.put("system_cpu", :cpu_sup.util())
                  # |> Map.put(
                  #   "system_disk",
                  #   :disksup.get_disk_data() |> Enum.map(fn {x, y, z} -> [x |> to_string(), y, z] end)
                  # )
                  |> Map.put("system_file_descriptor_count", :os.cmd('cat /proc/sys/fs/file-nr') |> to_string())
                  # |> Map.put("system_memory", :memsup.get_system_memory_data() |> Enum.into(%{}))
                  |> Map.put("system_uptime", :os.cmd('uptime') |> to_string())
                  |> Map.put(
                    "uptime",
                    (:erlang.system_time() - (:erlang.time_offset() + :erlang.system_info(:start_time))) /
                      1_000_000_000
                  )

                Log.info("system stat: #{inspect(system_stat)}")
                body = %{"status" => "success", "result" => system_stat} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/get_system_stat"
          - do:
              $action: "elixir"
              value: |
                # Log.info("data put: #{inspect v}")
                path = v["path"]["segment"]["data"] |> String.trim_trailing("/") |> String.split("/")
                # Log.info("data put: data: #{inspect v["body"]}")
                set(path, v["body"], flatten: true)
                # Log.info("data put: result: #{inspect get(path)}")
                body = %{"status" => "success", "result" => "data put"} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/data/{data} put"
          - do:
              $action: "elixir"
              value: |
                # Log.info("data get: #{inspect v}")
                path = v["path"]["segment"]["data"] |> String.trim_trailing("/") |> String.split("/")
                function("respond", %{"status" => "success", "result" => get(path)})
            model:
              $ref: "/api/data/{data} get"
          - do:
              $action: "elixir"
              value: |
                body = cond do
                  not is_map(v["body"])           -> %{"status" => "error", "result" => "Incorrect api structure"}
                  not is_list(v["body"]["path"])  -> %{"status" => "error", "result" => "Incorrect path structure"}
                  not is_map(v["body"]["value"])  -> %{"status" => "error", "result" => "Incorrect configuration structure"}
                  true                            ->
                    config_path = if v["body"]["path"], do: v["body"]["path"], else: []
                    set(["config"] ++ config_path, v["body"]["value"], flatten: true)
                    %{"status" => "success", "result" => "success"}
                end |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/config/add"
          - do:
              $action: "elixir"
              value: |
                function("save config")
                function("compile")
                function("respond", %{"status" => "success", "result" => "success"} |> Poison.encode!())
            model:
              $ref: "/api/config/commit"
          - do:
              $action: "elixir"
              value: |
                Log.info("config/setPath: " <> inspect(v))
                body = cond do
                  is_map(v["body"]) ->
                    path = ["config"] ++ v["body"]["path"]
                    set(path, v["body"]["value"], flatten: true)
                    # function("compile")
                    %{"status" => "success", "result" => v["body"]["value"]} |> Poison.encode!()
                  true ->
                    %{"status" => "error", "result" => "Incorrect configuration structure"} |> Poison.encode!()
                end
                function("respond", body)
            model:
              $ref: "/api/config/setPath"
          - do:
              $action: "elixir"
              value: |
                Log.info("config/removePath: " <> inspect(v))
                body = cond do
                  is_map(v["body"]) ->
                    path = ["config"] ++ v["body"]["path"]
                    clear(path)
                    # function("compile")
                    %{"status" => "success", "result" => v["body"]["path"]} |> Poison.encode!()
                  true ->
                    %{"status" => "error", "result" => "Incorrect configuration structure"} |> Poison.encode!()
                end
                function("respond", body)
            model:
              $ref: "/api/config/removePath"
          - do:
              $action: "elixir"
              value: |
                result = Interactor.Instance.get_status(Execution.State.new("edgehub_solution_default")) |> ISON.encode()

                body = %{"status" => "success", "result" => result} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/get_instance_status"
          - do:
              $action: "elixir"
              value: |
                Log.info("/api/admin/set_instance_status " <> inspect(v))
                result = if v["body"]["state"], do: Interactor.Instance.start(v["body"]["instance"], "edgehub_solution_default"), else: Interactor.Instance.stop(v["body"]["instance"], Execution.State.new("edgehub_solution_default"))
                Log.info("/api/admin/set_instance_status: result: " <> inspect(result))
                result = ''
                body = %{"status" => "success", "result" => result} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/set_instance_status"
          - do:
              $action: "elixir"
              value: |
                result = get(["stat"], default: "FAILED", project: "edgehub_solution_default")
                body = %{"status" => "success", "result" => result} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/get_device_stat"
          - model:
              $ref: "/api/admin/get_tag_stat"
          - do:
              $action: "elixir"
              value: |
                requested_keys = v["body"]["keys"]
                requested_path = v["body"]["path"]
                raw_string = get(["raw_string"] ++ requested_path, default: "FAILED", project: "edgehub_solution_default")
                raw = cond do
                  is_map(raw_string) -> raw_string |> Map.take(requested_keys)
                  true -> raw_string
                end
                binary_string = get(["binary_string"] ++ requested_path, default: "FAILED", project: "edgehub_solution_default")
                binary = cond do
                  is_map(binary_string) -> binary_string |> Map.take(requested_keys)
                  true -> binary_string
                end
                value_string = get(["value_string"] ++ requested_path, default: "FAILED", project: "edgehub_solution_default")
                value = cond do
                  is_map(value_string) -> value_string |> Map.take(requested_keys)
                  true -> value_string
                end
                # timestamp = get(["timestamp"] ++ requested_path ++ ["gap"], default: "FAILED", project: "edgehub_solution_default")
                # Log.info( get(["value_string"] ++ requested_path, default: "FAILED", project: "edgehub_solution_default"))
                timestamp = get(["timestamp"] ++ requested_path, default: "FAILED", project: "edgehub_solution_default")
                # Log.info("TEST: #{inspect (timestamp)}")
                body = %{"status" => "success", "result" => %{"raw" => raw, "binary" =>  binary, "value" => value, "timestamp" => timestamp}} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/get_tag_value_by_path"
          - do:
              $action: "elixir"
              value: |
                raw = get(["raw_string"],default: "FAILED", project: "edgehub_solution_default")
                binary = get(["binary_string"],default: "FAILED", project: "edgehub_solution_default")
                value = get(["value_string"],default: "FAILED", project: "edgehub_solution_default")
                body = %{"status" => "success", "result" => %{"raw" => raw, "binary" =>  binary, "value" => value}} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/get_tag_value"
        none:
           # Production mode
           $action: "http response"
           body:
             $action: "sequence"
             value:
               - $action: "match"
                 $set: "dir"
                 key: "path"
                 matches:
                   - model:
                       const: "/"
                     do: "/index.html"
                   - model:
                       type: "string"
                       pattern: "^/(js|css|fonts|img|favicon.ico)"
                     do:
                       $action: "get"
                       key: "path"
                 none: "/index.html"
               - $action: "function"
                 name: "read_file"

          # # Developement Mode
          #$action: "sequence"
          #value:
          #  - $action: "http request"
          #    $set: "response"
          #    headers:
          #      $action: "get"
          #      key: "headers"
          #    url:
          #      $action: "elixir"
          #      value: |
          #        "127.0.0.1:8081" <> v["path"]
          #  - $action: "http response"
          #    body:
          #      $action: "get"
          #      key:
          #        - "response"
          #        - "body"
          #    headers:
          #      $action: "elixir"
          #      value: |
          #        v["response"].headers |> Enum.into(%{})
    use: "http server"
  bootloader:
    data:
      count: 2
      interval: 100
    event:
      execute:
        $action: "elixir"
        value: |
          Log.info get("config")
          if (v["count"] > 1) do
            if (get("config") == nil) do
              set("config", get("defaultConfig"), flatten: true)
            end
            set("loaded", true)
          end
    use: "timer"
model:
  /api/add_first_user:
    $parser: "json"
    properties:
      path:
        const: "/api/add_first_user"
        type: "string"
    type: "object"
  /api/admin/get:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get"
        type: "string"
    type: "object"
  /api/admin/get_device_stat:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_device_stat"
        type: "string"
    type: "object"
  /api/admin/get_instance_status:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_instance_status"
        type: "string"
    type: "object"
  /api/admin/get_interactor_info:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_interactor_info"
        type: "string"
    type: "object"
  /api/admin/get_system_stat:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_system_stat"
        type: "string"
    type: "object"
  /api/admin/get_tag_stat:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_tag_stat"
        type: "string"
    type: "object"
  /api/admin/get_tag_value:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_tag_value"
        type: "string"
    type: "object"
  /api/admin/get_tag_value_by_path:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_tag_value_by_path"
        type: "string"
    type: "object"
  /api/admin/set:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/set"
        type: "string"
    type: "object"
  /api/admin/set_instance_status:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/set_instance_status"
        type: "string"
    type: "object"
  /api/config/add:
    $parser: "json"
    properties:
      method:
        regex: "(?i)post"
        type: "string"
      path:
        const: "/api/config/add"
        type: "string"
    type: "object"
  /api/config/clear:
    $parser: "json"
    properties:
      path:
        const: "/api/config/clear"
        type: "string"
    type: "object"
  /api/config/commit:
    $parser: "json"
    properties:
      method:
        regex: "(?i)post"
        type: "string"
      path:
        const: "/api/config/commit"
        type: "string"
    type: "object"
  /api/config/default:
    $parser: "json"
    properties:
      path:
        const: "/api/config/default"
        type: "string"
    type: "object"
  /api/config/get:
    $parser: "json"
    properties:
      path:
        const: "/api/config/get"
        type: "string"
    type: "object"
  /api/config/removePath:
    $parser: "json"
    properties:
      path:
        const: "/api/config/removePath"
        type: "string"
    type: "object"
  /api/config/set:
    $parser: "json"
    properties:
      path:
        const: "/api/config/set"
        type: "string"
    type: "object"
  /api/config/setPath:
    $parser: "json"
    properties:
      path:
        const: "/api/config/setPath"
        type: "string"
    type: "object"
  /api/data/{data} get:
    $parser: "json"
    properties:
      method:
        regex: "(?i)get"
        type: "string"
      path:
        $parser: "path"
        pattern: "/data/{*data}"
    type: "object"
  /api/data/{data} put:
    $parser: "json"
    properties:
      method:
        regex: "(?i)put"
        type: "string"
      path:
        $parser: "path"
        pattern: "/data/{*data}"
    type: "object"
  /api/is_first_user:
    $parser: "json"
    properties:
      path:
        const: "/api/is_first_user"
        type: "string"
    type: "object"
  /api/log/clear:
    $parser: "json"
    properties:
      path:
        const: "/api/log/clear"
        type: "string"
    type: "object"
  /api/log/get:
    $parser: "json"
    properties:
      path:
        const: "/api/log/get"
        type: "string"
    type: "object"
  /api/login:
    $parser: "json"
    properties:
      path:
        const: "/api/login"
        type: "string"
    type: "object"
  /api/logout:
    $parser: "json"
    properties:
      path:
        const: "/api/logout"
        type: "string"
    type: "object"
service:
  cnet:
    data:
      data_bits:
        default: 0
        input: true
        type: "integer"
      framing:
        default: "none"
        input: true
        type: "string"
      framing_separator:
        default: ""
        input: true
        type: "string"
      framing_timeout:
        default: 100
        input: true
        type: "integer"
      parity:
        default: "none"
        input: true
        type: "string"
      port:
        default: ""
        input: true
        required: true
        type: "string"
      speed:
        default: 115200
        input: true
        type: "integer"
      stop_bits:
        default: 0
        input: true
        type: "integer"
    function:
      error:
        logic:
          $action: "elixir"
          value: |
            (Log.info("cnet: action: error: v: " <> inspect(v))
              emit("error", v |> Map.put("error", "Unknown packet"))
            )
      read_tag:
        logic:
          $action: "elixir"
          value: |
            Log.info("cnet: function: read_tag: v: " <> inspect(v))
            tag_id = [v["_category"],v["_group"],v["_device"],v["_name"]]
            schedule_count_data = get(["scheduled_count", tag_id])
            scheduled_count = if (schedule_count_data), do: schedule_count_data, else: (set(["scheduled_count", tag_id], 0); 0)
            if (scheduled_count < 2) do
              scheduler_id = inspect System.os_time()
              set(["scheduler", scheduler_id], true)
              count(["scheduled_count", tag_id], 1)
              Log.info("cnet: function: read_tag: scheduler: " <> inspect(get(["scheduler"])))
              result = Enum.find_value(1..100000, false, fn x ->
                :timer.sleep(1)
                priority = get(["priority_scheduler"])
                priority_scheduler = if (priority), do: priority |> Map.keys(), else: []
                if (length(priority_scheduler) == 0) do
                  schedulers = get(["scheduler"]) |> Map.keys()
                  Enum.at(schedulers, 0) === scheduler_id
                else
                  false
                end
              end) |> if do
                key = v["_condition"]["address"]
                key_length = byte_size(key) |> Integer.to_string(16) |> String.pad_leading(2, "0")
                id = get("uid") |> Integer.to_string(16) |> String.pad_leading(2, "0")
                read_count = v["_condition"]["length"] |> Integer.to_string(16) |> String.pad_leading(2, "0")
                data = encode(%{
                  "id" => id,
                  "key_length" => key_length,
                  "key" => key,
                  "data_length" => read_count,
                  "command" => "r"
                }, "read_variable_continuous").result
                instance("client", "send", data)
                result = Enum.find_value(1..2000, <<>>, fn x ->
                  :timer.sleep(1)
                  received = instance("cnet", "read received")
                  if (received == ""), do: false, else: received
                end) |> case do
                  <<>> ->
                    Log.warn("cnet: function: read_tag: timeout:")
                    ""
                  received ->
                    ret = received |> Map.get("block_ACK") |> Enum.at(0) |> Map.get("data") |> Base.decode16!()
                    Log.info("cnet: function: read_tag: result: " <> inspect(ret))
                    ret
                end
                clear(["scheduler", scheduler_id])
                count(["scheduled_count", tag_id], -1)
                {:ok, result}
              else
                clear(["scheduler", scheduler_id])
                count(["scheduled_count", tag_id], -1)
                Log.warn("cnet: function: read_tag: timeout: " <> inspect(v))
                {:error, "timeout"}
              end
            else
              {:error, "queue full for tag: " <> inspect(tag_id)}
            end
      received:
        logic:
          $action: "elixir"
          value: |
            (Log.info("cnet: action: received: v: " <> inspect(v))
              emit("received", v)
            )
      send:
        logic:
          $action: "elixir"
          value: |
            (Log.info("cnet: function: send: v: " <> inspect(v))
              instance("master", "send", encode(v, "modbus rtu request") |> Map.get(:result))
            )
      write_tag:
        logic:
          $action: "elixir"
          value: |
            scheduler_id = inspect System.os_time()
            set(["priority_scheduler", scheduler_id], true)
            Log.info("cnet: function: write_tag: priority_scheduler: " <> inspect(get(["priority_scheduler"])))
            Log.info("cnet: function: write_tag: v: " <> inspect(v))
            result = Enum.find_value(1..100000, false, fn x ->
              :timer.sleep(1)
              schedulers = get(["priority_scheduler"]) |> Map.keys()
              Enum.at(schedulers, 0) === scheduler_id
            end) |> if do
              key = v["properties"]["_condition"]["address"]
              key_length = byte_size(key) |> Integer.to_string(16) |> String.pad_leading(2, "0")
              id = get("uid") |> Integer.to_string(16) |> String.pad_leading(2, "0")
              read_count = v["properties"]["_condition"]["length"] |> Integer.to_string(16) |> String.pad_leading(2, "0")
              write_data = key |> String.graphemes() |> Enum.at(2) |> case do
                "X" -> v["value"] |> Integer.to_string(16) |> String.pad_leading(1, "0")
                "B" -> v["value"] |> Integer.to_string(16) |> String.pad_leading(2, "0")
                "W" -> v["value"] |> Integer.to_string(16) |> String.pad_leading(4, "0")
                "D" -> v["value"] |> Integer.to_string(16) |> String.pad_leading(8, "0")
                "L" -> v["value"] |> Integer.to_string(16) |> String.pad_leading(16, "0")
                _ -> v["value"] |> Integer.to_string(16) |> String.pad_leading(2, "0")
              end
              Log.info("cnet: function: write_tag: write_data: " <> inspect(write_data))
              data = encode(%{
                "id" => id,
                "key_length" => key_length,
                "key" => key,
                "data_length" => read_count,
                "command" => "w",
                "data" => write_data
              }, "write_variable_continuous").result
              Log.info("cnet: function: write_tag: send: " <> inspect(data))
              instance("client", "send", data)
              result = Enum.find_value(1..2000, <<>>, fn x ->
                :timer.sleep(1)
                received = instance("cnet", "read received")
                if (received == ""), do: false, else: received
              end) |> case do
                <<>> -> Log.info("cnet: function: write_tag: timeout:")
                ret ->
                  Log.info("cnet: function: write_tag: result: " <> inspect(ret))
                  ret
              end
              clear(["priority_scheduler", scheduler_id])
              {:ok, result}
            else
              clear(["priority_scheduler", scheduler_id])
              Log.warn("cnet: function: write_tag: timeout: " <> inspect(v))
              {:error, "timeout"}
            end
    instance:
      client:
        data:
          data_bits:
            $action: "elixir"
            value: |
              get("data_bits")
          framing:
            $action: "elixir"
            value: |
              get("framing")
          framing_separator:
            $action: "elixir"
            value: |
              get("framing_separator")
          framing_timeout:
            $action: "elixir"
            value: |
              get("framing_timeout")
          models:
            - "read_variable_ACK"
            - "write_variable_or_register_monitor_ACK"
            - "read_monitor_format_continuous_ACK"
            - "read_monitor_format_individual_ACK"
            - "monitor_NAK"
            - "variable_NAK"
            - "read_variable_continuous"
            - "read_monitor"
            - "read_variable_individual"
            - "register_monitor_format_continuous"
            - "register_monitor_format_individual"
            - "write_variable_continuous"
            - "write_variable_individual"
          parity:
            $action: "elixir"
            value: |
              get("parity")
          port:
            $action: "elixir"
            value: |
              get("port")
          speed:
            $action: "elixir"
            value: |
              get("speed")
          stop_bits:
            $action: "elixir"
            value: |
              get("stop_bits")
        event:
          monitor_NAK:
            $action: "log"
            label: "monitor_NAK"
          read_monitor:
            $action: "log"
            label: "Loopback"
          read_monitor_format_continuous_ACK:
            $action: "log"
            label: "read_monitor_format_continuous_ACK"
          read_monitor_format_individual_ACK:
            $action: "log"
            label: "read_monitor_format_individual_ACK"
          read_variable_ACK:
            $action: "log"
            label: "read_variable_ACK"
          read_variable_continuous:
            $action: "log"
            label: "Loopback"
          read_variable_individual:
            $action: "log"
            label: "Loopback"
          received:
            none:
              $action: "elixir"
              value: |
                Log.info(v)
            key:
              - "data"
          register_monitor_ACK:
            $action: "log"
            label: "register_monitor_ACK"
          register_monitor_format_continuous:
            $action: "log"
            label: "Loopback"
          register_monitor_format_individual:
            $action: "log"
            label: "Loopback"
          variable_NAK:
            $action: "log"
            label: "variable_NAK"
          write_variable_continuous:
            $action: "log"
            label: "Loopback"
          write_variable_individual:
            $action: "log"
            label: "write_variable_individual"
          write_variable_or_register_monitor_ACK:
            $action: "log"
            label: "write_variable_or_register_monitor_ACK"
        use: "serial"
    model:
      block_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data_length"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data"
            options: {}
            size:
              $action: "elixir"
              value: |
                Log.info(v)
                data_size = ( if v[:__fields__] !== nil do
                    Log.info("encoding1")
                    v["data"] |> byte_size
                  else
                    Log.info("decoding1")
                    (v["__state__"].data |> byte_size) - 1
                  end)
                Log.info(data_size)
                data_length = String.to_integer(v["data_length"], 16)
                Log.info(data_length)
                cond do
                  ((data_length * 8 === data_size) || (data_length * 8 === data_size - 2)) ->
                    # Long word
                    Log.info("8")
                    data_length * 8
                  ((data_length * 4 === data_size) || (data_length * 4 === data_size - 2)) ->
                    # Double word
                    Log.info("4")
                    data_length * 4
                  ((data_length * 2 === data_size) || (data_length * 2 === data_size - 2)) ->
                    # Word
                    Log.info("2")
                    data_length * 2
                  ((data_length === data_size) || (data_length === data_size - 2)) ->
                    # Byte, Bit
                    Log.info("1")
                    data_length * 1
                end
            type: "bytes"
      block_read:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key_length"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key"
            options: {}
            size:
              $action: "elixir"
              value: |
                String.to_integer(v["key_length"])
            type: "bytes"
      block_write:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key_length"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key"
            options: {}
            size:
              $action: "elixir"
              value: |
                String.to_integer(v["key_length"])
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00AB"
            name: "data"
            options: {}
            size: 4
            type: "bytes"
      monitor_NAK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 21
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "Y"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
            validator:
              $action: "elixir"
              value: |
                v["this"] in ["x", "X", "y", "Y"]
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01"
            name: "reg_num"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "1132"
            name: "error_code"
            options: {}
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
      read_monitor:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 5
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "Y"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
            validator:
              $action: "elixir"
              value: |
                v["this"] in ["y", "Y"]
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01"
            name: "reg_num"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 4
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
        testInput:
          encode: |
            %{
              "reg_num" => "02"
            }
      read_monitor_format_continuous_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "Y"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
            validator:
              $action: "elixir"
              value: |
                v["this"] in ["y", "Y"]
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "02"
            name: "reg_num"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count: 1
            model: "block_ACK"
            name: "block_ACK"
            overrides: {}
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
      read_monitor_format_individual_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "Y"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
            validator:
              $action: "elixir"
              value: |
                v["this"] in ["y", "Y"]
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01"
            name: "reg_num"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01"
            name: "block_count"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                String.to_integer(v["block_count"])
            model: "block_ACK"
            name: "block_ACK"
            overrides: {}
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
      read_variable_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "R"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
            validator:
              $action: "elixir"
              value: |
                v["this"] in ["r", "R"]
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command_type"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "block_count"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                String.to_integer(v["block_count"])
            model: "block_ACK"
            name: "block_ACK"
            overrides: {}
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
        testInput:
          decode: " <<6, 48, 48, 114, 83, 66, 48, 49, 48, 65, 49, 50, 51, 52, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 3, 48, 67>>"
          encode: |
            %{
              "block_ACK" => [
                %{"data" => "5F238BDAD6FAEF5FA1FFBFBA6E6D1FF7", "data_length" => "10"}
              ],
              "block_count" => "01",
              "command" => "R",
              "command_type" => "SB",
              "header" => 6,
              "id" => "00",
              "tail" => 3
            }
      read_variable_continuous:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 5
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "R"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
            validator:
              $action: "elixir"
              value: |
                v["this"] in ["r", "R"]
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command_type"
            options: {}
            size: 2
            type: "bytes"
            value: "SB"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key_length"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key"
            options: {}
            size:
              $action: "elixir"
              value: |
                String.to_integer(v["key_length"])
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data_length"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 4
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
        testInput:
          decode: "<<5, 48, 48, 114, 83, 66, 48, 54, 37, 77, 87, 49, 48, 48, 48, 53, 4, 57, 53>>"
          encode: |
            %{
              "key_length" => "06",
              "key" => "%MW100",
              "data_length" => "05",
              "command" => "r"
            }
      read_variable_individual:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 5
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "R"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
            validator:
              $action: "elixir"
              value: |
                v["this"] in ["r", "R"]
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command_type"
            options: {}
            size: 2
            type: "bytes"
            value: "SS"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01"
            name: "block_count"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                String.to_integer(v["block_count"])
            model: "block_read"
            name: "block_read"
            overrides: {}
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 4
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
        testInput:
          encode: |
            %{
              "block_read" => [%{
                "key_length" => "06",
                "key" => "%MW100"
              }]
            }
      register_monitor_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "W"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01"
            name: "reg_num"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
      register_monitor_format_continuous:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 5
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "X"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
            validator:
              $action: "elixir"
              value: |
                v["this"] in ["x", "X"]
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "02"
            name: "reg_num"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command_type"
            options: {}
            size: 3
            type: "bytes"
            value: "RSB"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key_length"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key"
            options: {}
            size:
              $action: "elixir"
              value: |
                String.to_integer(v["key_length"])
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data_length"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 4
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
        testInput:
          encode: |
            %{
              "key_length" => "06",
              "key" => "%MW100",
              "data_length" => "08",
              "command" => "x"
            }
      register_monitor_format_individual:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 5
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "X"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
            validator:
              $action: "elixir"
              value: |
                v["this"] in ["x", "X"]
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01"
            name: "reg_num"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command_type"
            options: {}
            size: 3
            type: "bytes"
            value: "RSS"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01"
            name: "block_count"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                String.to_integer(v["block_count"])
            model: "block_read"
            name: "block_read"
            overrides: {}
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 4
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
        testInput:
          encode: |
            %{
              "block_read" => [%{
                "key_length" => "06",
                "key" => "%MW100"
              }],
              "command" => "x"
            }
      variable_NAK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 21
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
            validator:
              $action: "elixir"
              value: |
                v["this"] in ["w", "W", "r", "R"]
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command_type"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "1132"
            name: "error_code"
            options: {}
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
      write_variable_continuous:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 5
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "W"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
            validator:
              $action: "elixir"
              value: |
                v["this"] in ["w", "W"]
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command_type"
            options: {}
            size: 2
            type: "bytes"
            value: "SB"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key_length"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key"
            options: {}
            size:
              $action: "elixir"
              value: |
                String.to_integer(v["key_length"])
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data_length"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data"
            options: {}
            size:
              $action: "elixir"
              value: |
                4 * String.to_integer(v["data_length"])
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 4
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
        testInput:
          decode: "<<5, 48, 48, 119, 83, 66, 48, 54, 37, 77, 87, 49, 48, 48, 48, 53, 48, 48, 48,  49, 48, 48, 48, 50, 48, 48, 48, 51, 48, 48, 48, 52, 48, 48, 48, 53, 4, 54, 57>>"
          encode: "%{\"key_length\" => \"06\", \"key\" => \"%MW100\", \"data_length\" => \"05\", \"command\"=>\"w\", \"data\"=>\"00010002000300040005\"}"
      write_variable_individual:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 5
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "W"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
            validator:
              $action: "elixir"
              value: |
                v["this"] in ["w", "W"]
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command_type"
            options: {}
            size: 2
            type: "bytes"
            value: "SS"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01"
            name: "block_count"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                String.to_integer(v["block_count"])
            model: "block_write"
            name: "block_write"
            overrides: {}
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 4
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
        testInput:
          decode: |
            <<5, 48, 48, 119, 83, 83, 48, 49, 48, 54, 37, 77, 87, 49, 48, 48, 49, 50, 51,
              52, 53, 54, 55, 56, 4, 52, 66>>
          encode: |
            %{
              "block_write" => [%{
                "key_length" => "06",
                "key" => "%MW100",
                "data" => "1234"
              }],
              "command" => "w"
            }
      write_variable_or_register_monitor_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "header"
            options: {}
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "W"
            name: "command"
            options: {}
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command_type"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tail"
            options: {}
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                Log.info(v)
                if v["command"] > "Z" do
                  if v[:__fields__] !== nil do
                    Log.info("encoded")
                    v[:__fields__] |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  else
                    Log.info("decoded")
                    v["__state__"].parsed() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.reverse() |> binary_part(0,2) |> String.reverse()
                  end
                else
                  <<>>
                end
            name: "bcc"
            options: {}
            size:
              $action: "elixir"
              value: |
                if v["command"] > "Z" do 2 else 0 end
            type: "bytes"
  fenet:
    data:
      address:
        input: true
        required: true
        type: "string"
      port:
        input: true
        required: true
        type: "number"
    function:
      read_status_test:
        logic:
          $action: "elixir"
          value: |
            data = encode(%{
              "body" => %{"command" => 176, "data_type" => 0, "reserved" => 0},
              "header" => %{
                "bcc" => <<0>>,
                "company_id" => <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>,
                "company_id_reserved" => 0,
                "cpu_info" => 160,
                "invoke_id" => <<0, 1>>,
                "plc_info" => 164,
                "source_of_frame" => 51,
                "module_position" => %{
                 "module_slot" => <<1::size(4)>>,
                 "module_base" => <<5::size(4)>>
                }
              }
            }, "read_status").result
            # instance("fenet", "send", data)
      read_tag:
        logic:
          $action: "elixir"
          value: |
            Log.info("fenet: function: read_tag: v: " <> inspect(v))
            address = get("address")
            port = get("port")
            slot = get("slot")
            base = get("base")
            company_id = get("company_id") |> case do
             "LSIS-XGT" -> <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>
             "LSIS_GLOFA" -> <<76, 83, 73, 83, 45, 71, 76, 79, 70, 65>>
            end
            cpu_info = get("cpu_info") |> case do
              "XGK" -> 160
              "XGI" -> 164
              "XGR" -> 168
            end
            key = v["_condition"]["address"]
            key_length = byte_size(key)
            read_count = key |> String.graphemes() |> Enum.at(2) |> case do
              "X" -> v["_condition"]["length"]
              "B" -> v["_condition"]["length"]
              "W" -> 2 * v["_condition"]["length"]
              "D" -> 4 * v["_condition"]["length"]
              "L" -> 8 * v["_condition"]["length"]
              _ -> v["_condition"]["length"]
            end
            # read_count = v["_condition"]["length"]
            data = encode(%{
              "body" => %{
                "block_count" => 1,
                "block_key" => [
                  %{"key" => key, "key_length" => key_length, "read_count" => read_count}
                ],
                "command" => 84,
                "data_type" => 20,
                "reserved" => 0
              },
              "header" => %{
                "company_id" => <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>,
                "cpu_info" => cpu_info,
                "invoke_id" => <<0, 1>>,
                "module_position" => %{
                 "module_slot" => <<slot::size(4)>>,
                 "module_base" => <<base::size(4)>>
                }
             }
            }, "read_variable_continuous").result
            Log.info("fenet: function: read_tag: data: " <> inspect(data))
            result = Service.Tcp.send_and_recv(address, port, data) |> case do
              {:ok, ret} ->
                Log.info("fenet: function: read_tag: ret: " <> inspect(ret))
                decoded = function("read_tag_match", ret)
                {:ok, decoded}
              error ->
                Log.info("fenet: function: read_tag: error: " <> inspect(error))
                {:error, %{}}
            end
            Log.info("fenet: function: read_tag: result: " <> inspect(result))
            result
      read_tag_match:
        logic:
          $action: "match"
          matches:
            - do:
                $action: "elixir"
                value: |
                  Log.info("NAK: " <> inspect(v))
                  v |> Map.get("body") |> Map.get("error_code")
              model:
                $ref: "NAK"
            - do:
                $action: "elixir"
                value: |
                  Log.info("read_variable_ACK: " <> inspect(v))
                  v |> Map.get("body") |> Map.get("block_data") |> Enum.at(0) |> Map.get("data")
              model:
                $ref: "read_variable_ACK"
      read_variable_continuous_test:
        logic:
          $action: "elixir"
          value: |
            data = encode(%{
              "body" => %{
                "block_count" => 1,
                "block_key" => [
                  %{"key" => "%NB0", "key_length" => 4, "read_count" => 7}
                ],
                "command" => 84,
                "data_type" => 20,
                "reserved" => 0
              },
              "header" => %{
                "company_id" => <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>,
                "cpu_info" => 160,
                "invoke_id" => <<0, 1>>,
                "module_position" => %{
                 "module_slot" => <<1::size(4)>>,
                 "module_base" => <<5::size(4)>>
                }
             }
            }, "read_variable_continuous").result
            # instance("fenet", "send", data)
      send:
        logic:
          $action: "elixir"
          value: |
            (Log.info("fenet: function: send: v: " <> inspect(v))
              instance("client", "send", encode(v, "modbus tcp request") |> Map.get(:result))
            )
      write_tag:
        logic:
          $action: "elixir"
          value: |
            Log.info("fenet: function: write_tag: v: " <> inspect(v))
            address = get("address")
            Log.info("fenet: function: write_tag: address: " <> inspect(address))
            port = get("port")
            Log.info("fenet: function: write_tag: port: " <> inspect(port))
            slot = get("slot")
            Log.info("fenet: function: write_tag: slot: " <> inspect(slot))
            base = get("base")
            Log.info("fenet: function: write_tag: base: " <> inspect(base))
            company_id = get("company_id") |> case do
             "LSIS-XGT" -> <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>
             "LSIS_GLOFA" -> <<76, 83, 73, 83, 45, 71, 76, 79, 70, 65>>
            end
            Log.info("fenet: function: write_tag: company_id: " <> inspect(company_id))
            cpu_info = get("cpu_info") |> case do
              "XGK" -> 160
              "XGI" -> 164
              "XGR" -> 168
            end
            Log.info("fenet: function: write_tag: cpu_info: " <> inspect(cpu_info))
            key = v["properties"]["_condition"]["address"]
            Log.info("fenet: function: write_tag: key: " <> inspect(key))
            key_length = byte_size(key)
            Log.info("fenet: function: write_tag: key_length: " <> inspect(key_length))
            data_size = v["properties"]["_condition"]["length"] * 8
            Log.info("fenet: function: write_tag: data_size: " <> inspect(data_size))
            write_data = v["value"]
            Log.info("fenet: function: write_tag: write_data: " <> inspect(write_data))

            data = encode(%{
              "body" => %{
                "block_count" => 1,
                "block_key" => [
                  %{"key" => key, "key_length" => key_length, "data" => <<write_data :: size(data_size)>>}
                ],
                "command" => 88,
                "data_type" => 20,
                "reserved" => 0
              },
              "header" => %{
                "company_id" => company_id,
                "cpu_info" => cpu_info,
                "invoke_id" => <<0, 1>>,
                "module_position" => %{
                 "module_slot" => <<slot::size(4)>>,
                 "module_base" => <<base::size(4)>>
                }
             }
            }, "write_variable_continuous").result
            Log.info("fenet: function: write_tag: data: " <> inspect(data))
            result = Service.Tcp.send_and_recv(address, port, data) |> case do
              {:ok, ret} ->
                Log.info("fenet: function: write_tag: ret: " <> inspect(ret))
                {:ok, ret |> decode("write_variable_ACK") |> Map.get(:result) |> Map.get("body") |> Map.get("error_state")}
              error ->
                Log.info("fenet: function: write_tag: error: " <> inspect(error))
                {:error, %{}}
            end
            Log.info("fenet: function: write_tag: result: " <> inspect(result))
            result
    instance:
      client:
        data:
          address:
            $action: "elixir"
            value: |
              get("address")
          port:
            $action: "elixir"
            value: |
              get("port")
        event:
          connected:
            $action: "elixir"
            value: |
              Log.info("connected")
          disconnected:
            $action: "elixir"
            value: |
              Log.info("disconnected")
          received:
            $action: "match"
            matches:
              - do:
                  $action: "elixir"
                  value: |
                    Log.info("NAK")
                     v["data"]["__state__"] |> Map.get(:result) |> Log.info()
                model:
                  $ref: "NAK"
              - do:
                  $action: "elixir"
                  value: |
                    Log.info("read_variable_ACK")
                     v["data"]["__state__"] |> Map.get(:result) |> Log.info()
                model:
                  $ref: "read_variable_ACK"
              - do:
                  $action: "elixir"
                  value: |
                    Log.info("read_status_ACK")
                     v["data"]["__state__"] |> Map.get(:result) |> Log.info()
                model:
                  $ref: "read_status_ACK"
              - do:
                  $action: "elixir"
                  value: |
                    Log.info("write_variable_ACK")
                     v["data"]["__state__"] |> Map.get(:result) |> Log.info()
                model:
                  $ref: "write_variable_ACK"
            key:
              - "data"
        use: "tcp client"
    model:
      NAK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "header"
            name: "header"
            overrides:
              source_of_frame:
                value: 17
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "body_NAK"
            name: "body"
            overrides: {}
        testInput:
          decode: "<<76, 71, 73, 83, 45, 71, 76, 79, 70, 65, 2,1, 164, 33, 0, 1, 20, 0, 1::size(4), 5::size(4), 3, 54, 0, 32, 0, 0 , 0, 255, 255, 0, 0>>"
          encode: |
            %{
              "body" => %{
                "command" => 54,
                "data_type" => 32,
                "error_code" => 0,
                "error_state" => 65535,
                "reserved" => 0
              },
              "header" => %{
                "bcc" => <<3>>,
                "company_id" => <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>,
                "cpu_info" => 160,
                "invoke_id" => <<0, 1>>,
                "length" => 20,
                "plc_info" => 258
              }
            }
      block_data:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data_length"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data"
            options: {}
            size:
              $action: "elixir"
              value: |
                v["data_length"]
            type: "bytes"
        testInput:
          decode: "<<2,0,1,3>>"
          encode: "%{\"data\" => <<1, 3>>, \"data_length\" => 2}"
      block_key:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key_length"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key"
            options: {}
            size:
              $action: "elixir"
              value: |
                v["key_length"]
            type: "bytes"
        testInput:
          decode: "<<2,0,1,1>>"
          encode: "%{\"key\" => <<1, 1>>, \"key_length\" => 2}"
      block_key_continuous_read:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key_length"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key"
            options: {}
            size:
              $action: "elixir"
              value: |
                v["key_length"]
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "read_count"
            options:
              endianness: "little"
            size: 2
            type: "integer"
        testInput:
          decode: "<<2,0,1,1,1,255>>"
          encode: "%{\"key\" => <<1, 1>>, \"key_length\" => 2, \"read_count\" => 65281}"
      block_key_continuous_write:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key_length"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "key"
            options: {}
            size:
              $action: "elixir"
              value: |
                v["key_length"]
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data"
            options: {}
            size:
              $action: "elixir"
              value: |
                cond do
                  v[:__fields__] === nil ->
                    v["__state__"].data |> byte_size
                  v["data"] === nil ->
                    0
                  v["data"] !== nil ->
                    v["data"] |> byte_size
                end
            type: "bytes"
        testInput: {}
      block_module_position:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "module_slot"
            options:
              endianness: "little"
            size: 4
            type: "bits"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "module_base"
            options:
              endianness: "little"
            size: 4
            type: "bits"
      body_NAK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data_type"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "reserved"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "error_state"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 65535
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "error_code"
            options:
              endianness: "little"
            size: 2
            type: "integer"
        testInput:
          decode: "<<54, 0, 32, 0, 0 , 0, 255, 255, 0, 0>>"
      body_read_status:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 176
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data_type"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 0
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "reserved"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 0
        testInput:
          decode: ""
          encode: "%{\"command\" => 176, \"data_type\" => 0, \"reserved\" => 0}"
      body_read_status_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 177
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data_type"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "reserved"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "error_state"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "reserved"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data_size"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 24
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "status_data"
            name: "status_data"
            overrides: {}
        testInput:
          decode: "<<0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0xff, 0x00, 0x00, 0x40, 0x01, 0xa4, 0x02, 0x00, 0x51, 0x10, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x5e, 0x59>>"
          encode: |
            %{
              "command" => 177,
              "data" => 0,
              "data_size" => 24,
              "data_type" => 0,
              "error_state" => 0,
              "reserved" => 0
            }
      body_read_variable_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 85
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 2
            name: "data_type"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "reserved"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "error_state"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 0
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 1
            name: "block_count"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["block_count"]
            model: "block_data"
            name: "block_data"
            overrides: {}
        testInput:
          decode: "<<85, 0, 2, 0, 0, 0, 0, 0, 1, 0, 2, 0, 1, 3>>"
      body_read_variable_continuous:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 84
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 20
            name: "data_type"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "reserved"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 0
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 1
            name: "block_count"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["block_count"]
            model: "block_key_continuous_read"
            name: "block_key"
            overrides: {}
        testInput:
          decode: "<<84, 0, 20, 0, 0, 0, 1, 0, 2, 0, 1, 1, 1, 255>>"
      body_read_variable_individual:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "command"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 84
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 2
            name: "data_type"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "reserved"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 0
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 1
            name: "block_count"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["block_count"]
            model: "block_key"
            name: "block_key"
            overrides: {}
        testInput:
          decode: "<<84, 0, 2, 0, 0, 0, 1, 0, 2, 0, 1, 1>>"
          encode: ""
      body_write_variable_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            validator:
              $action: "elixir"
              value: |
                v["this"] == 89
            value: 89
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 2
            name: "data_type"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "reserved"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 0
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "error_state"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            validator:
              $action: "elixir"
              value: |
                v["this"] == 0
            value: 0
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 1
            name: "block_count"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            validator:
              $action: "elixir"
              value: |
                v["this"] != 0
        testInput:
          decode: "<<89, 0, 2, 0, 0, 0, 0, 0, 1, 0>>"
      body_write_variable_continuous:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 88
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data_type"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            validator:
              $action: "elixir"
              value: |
                v["this"] == 20
            value: 20
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "reserved"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 0
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "block_count"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 1
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["block_count"]
            model: "block_key_continuous_write"
            name: "block_key"
            overrides: {}
        testInput:
          decode: "<<88, 0, 20, 0, 0, 0, 1, 0, 2, 0, 1, 1, 1, 255>>"
      body_write_variable_individual:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 88
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 2
            name: "data_type"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            validator:
              $action: "elixir"
              value: |
                v["this"] != 20
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "reserved"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value: 0
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 1
            name: "block_count"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["block_count"]
            model: "block_key"
            name: "block_key"
            overrides: {}
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["block_count"]
            model: "block_data"
            name: "block_data"
            overrides: {}
        testInput:
          decode: "<<88, 0, 19, 0, 0, 0, 1, 0, 2, 0, 1, 1, 2, 0, 1, 3>>"
      header:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "<<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>"
            name: "company_id"
            options: {}
            size: 10
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "plc_info"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 164
            name: "cpu_info"
            options:
              endianness: "little"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 51
            name: "source_of_frame"
            options:
              endianness: "little"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                ("0001" |> Base.decode16!(case: :upper))
            name: "invoke_id"
            options: {}
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                v[:__fields__]["body"] |> byte_size
            name: "length"
            options:
              endianness: "little"
              units: "bytes"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_module_position"
            name: "module_position"
            overrides: {}
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default:
              $action: "elixir"
              value: |
                a= v[:__fields__]["header"] |> Map.values() |> :binary.list_to_bin

                b = <<i <- a>> |> for do
                 i
                end |> Enum.reduce(0, &Kernel.+/2)
                <<b>>
            name: "bcc"
            options: {}
            size: 1
            type: "bytes"
        testInput:
          decode: "<<76, 71, 73, 83, 45, 88, 71, 84, 0, 0, 2, 1, 164, 51, 0, 1, 20, 0, 1::size(4), 5::size(4), 3>>"
      read_status:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "header"
            name: "header"
            overrides:
              source_of_frame:
                value: 51
            requires: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "body_read_status"
            name: "body"
            overrides: {}
        testInput:
          decode: "<<76, 71, 73, 83, 45, 88, 71, 84, 0, 0, 2, 1, 164, 51, 0, 1, 20, 0, 1::size(4), 5::size(4), 3, 176, 0, 0, 0, 0, 0>>"
          encode: |
            %{
              "body" => %{"command" => 176, "data_type" => 0, "reserved" => 0},
              "header" => %{
                "company_id" => <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>,
                "cpu_info" => 160,
                "invoke_id" => <<0, 1>>,
                "plc_info" => 0
              }
            }
      read_status_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "header"
            name: "header"
            overrides:
              source_of_frame:
                value: 17
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "body_read_status_ACK"
            name: "body"
            overrides: {}
        testInput:
          decode: "<<76, 71, 73, 83, 45, 71, 76, 79, 70, 65, 2, 1, 164, 17, 0, 1, 20, 0, 21, 3,177, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0>>"
          encode: |
            %{
              "body" => %{
                "command" => 177,
                "data" => 0,
                "data_size" => 24,
                "data_type" => 0,
                "error_state" => 0,
                "reserved" => 0
              },
              "header" => %{
                "bcc" => <<3>>,
                "company_id" => <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>,
                "cpu_info" => 160,
                "invoke_id" => <<0, 1>>,
                "length" => 20,
                "plc_info" => 258,
                "source_of_frame" => 33
              }
            }
      read_variable_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "header"
            name: "header"
            overrides:
              source_of_frame:
                value: 17
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "body_read_variable_ACK"
            name: "body"
            overrides: {}
        testInput:
          decode: "<<0x4c, 0x53, 0x49, 0x53, 0x2d, 0x58, 0x47, 0x54, 0x00, 0x00, 0x01, 0x01, 0xa4, 0x11, 0x00, 0x01, 0x24, 0x00, 0x00, 0x37, 0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0xff, 0x00, 0x00, 0x40, 0x01, 0xa4, 0x02, 0x00, 0x51, 0x10, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x5e, 0x59>>"
          encode: |
            %{
              "body" => %{
                "block_count" => 1,
                "block_data" => [%{"data" => <<1, 3>>, "data_length" => 2}],
                "command" => 85,
                "data_type" => 2,
                "error_state" => 0,
                "reserved" => 0
              },
              "header" => %{
                "bcc" => <<3>>,
                "company_id" => <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>,
                "cpu_info" => 160,
                "invoke_id" => <<0, 1>>,
                "length" => 20,
                "plc_info" => 258,
                "source_of_frame" => 33
              }
            }
      read_variable_continuous:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "header"
            name: "header"
            overrides:
              source_of_frame:
                value: 51
            requires: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "body_read_variable_continuous"
            name: "body"
            overrides: {}
        testInput:
          decode: |
            <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0, 0, 0, 164, 51, 0, 1, 16, 0, 0, 69, 84,
              0, 20, 0, 0, 0, 1, 0, 4, 0, 37, 78, 66, 48, 7, 0>>
          encode: |
            %{
                "body" => %{
                  "block_count" => 1,
                  "block_key" => [%{"key" => "%NB0", "key_length" => 4, "read_count" => 7}],
                  "command" => 84,
                  "data_type" => 20,
                  "reserved" => 0
                },
                "header" => %{
                  "bcc" => "E",
                  "company_id" => <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>,
                  "cpu_info" => 160,
                  "invoke_id" => <<0, 1>>,
                  "length" => 16,
                  "module_position" => %{
                    "module_base" => <<0::size(4)>>,
                    "module_slot" => <<0::size(4)>>
                  },
                  "plc_info" => 0,
                  "source_of_frame" => 51
                }
              }
      read_variable_individual:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "header"
            name: "header"
            overrides:
              source_of_frame:
                value: 51
            requires: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "body_read_variable_individual"
            name: "body"
            overrides: {}
        testInput:
          decode: |
            <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0, 0, 0, 164, 51, 0, 1, 16, 0, 21, 88, 84,
              0, 2, 0, 0, 0, 1, 0, 6, 0, 37, 77, 87, 49, 48, 48>>
          encode: |
            %{
              "body" => %{
                "block_count" => 1,
                "block_key" => [%{"key" => "%MW100", "key_length" => 6}],
                "command" => 84,
                "data_type" => 2,
                "reserved" => 0
              },
              "header" => %{
                "bcc" => "X",
                "company_id" => <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>,
                "cpu_info" => 160,
                "invoke_id" => <<0, 1>>,
                "length" => 16,
                "module_position" => %{
                  "module_base" => <<5::size(4)>>,
                  "module_slot" => <<1::size(4)>>
                },
                "plc_info" => 0,
                "source_of_frame" => 51
              }
            }
      slot_info:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "outgoing_slot_info"
            options:
              endianness: "little"
            size: 4
            type: "bits"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "outgoing_base_info"
            options:
              endianness: "little"
            size: 4
            type: "bits"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "incoming_slot_info"
            options:
              endianness: "little"
            size: 4
            type: "bits"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "incoming_base_info"
            options:
              endianness: "little"
            size: 4
            type: "bits"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "current_slot_info"
            options:
              endianness: "little"
            size: 4
            type: "bits"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "current_base_info"
            options:
              endianness: "little"
            size: 4
            type: "bits"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "reserved"
            options:
              endianness: "little"
            size: 8
            type: "bits"
        testInput:
          decode: "<<0xff, 0x00, 0x00, 0x40>>"
          encode: ""
      status_data:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "slot_info"
            name: "slot_info"
            overrides: {}
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "CPU_TYPE"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "PADT_CNF"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "SYS_STATE"
            options:
              endianness: "little"
            size: 4
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "CNF_ER"
            options:
              endianness: "little"
            size: 4
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "CNF_WAR"
            options:
              endianness: "little"
            size: 4
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "VER_NUM"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "reserved"
            options:
              endianness: "little"
            size: 2
            type: "integer"
        testInput:
          decode: "<<0xff, 0x00, 0x00, 0x40, 0x01, 0xa4, 0x02, 0x00, 0x51, 0x10, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x5e, 0x59>>"
          encode: ""
      write_variable_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "header"
            name: "header"
            overrides:
              source_of_frame:
                value: 17
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "body_write_variable_ACK"
            name: "body"
            overrides: {}
        testInput:
          decode: |
            <<76, 71, 73, 83, 45, 71, 76, 79, 70, 65, 2, 1, 164, 17, 0, 1, 20, 0, 21, 3, 89,
              0, 2, 0, 0, 0, 0, 0, 1, 0>>
          encode: |
            %{
              "body" => %{
                "block_count" => 1,
                "command" => 89,
                "data_type" => 2,
                "error_state" => 0,
                "reserved" => 0
              },
              "header" => %{
                "bcc" => <<3>>,
                "company_id" => <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>,
                "cpu_info" => 160,
                "invoke_id" => <<0, 1>>,
                "length" => 20,
                "plc_info" => 258
              }
            }
      write_variable_continuous:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "header"
            name: "header"
            overrides:
              command:
                value: 88
            requires: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "body_write_variable_continuous"
            name: "body"
            overrides: {}
        testInput:
          decode: |
            <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0, 0, 0, 164, 33, 0, 1, 20, 0, 0, 55, 88,
              0, 20, 0, 0, 0, 1, 0, 6, 0, 37, 77, 66, 49, 48, 48, 0, 0, 0, 0>>
          encode: |
            %{
              "body" => %{
                "block_count" => 1,
                "block_key" => [
                  %{"data" => <<0, 0, 0, 0>>, "key" => "%MB100", "key_length" => 6}
                ],
                "command" => 88,
                "data_type" => 20,
                "reserved" => 0
              },
              "header" => %{
                "bcc" => "7",
                "company_id" => <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>,
                "cpu_info" => 160,
                "invoke_id" => <<0, 1>>,
                "length" => 20,
                "module_position" => %{
                  "module_base" => <<0::size(4)>>,
                  "module_slot" => <<0::size(4)>>
                },
                "plc_info" => 0,
                "source_of_frame" => 33
              }
            }
      write_variable_individual:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "header"
            name: "header"
            overrides:
              source_of_frame:
                value: 51
            requires: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "body_write_variable_individual"
            name: "body"
            overrides: {}
        testInput:
          decode: |
            <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0, 0, 0, 164, 51, 0, 1, 22, 0, 0, 75, 88,
              0, 2, 0, 0, 0, 1, 0, 6, 0, 37, 77, 87, 49, 48, 48, 4, 0, 52, 54, 54, 48>>
          encode: |
            %{
              "body" => %{
                "block_count" => 1,
                "block_data" => [%{"data" => "4660", "data_length" => 4}],
                "block_key" => [%{"key" => "%MW100", "key_length" => 6}],
                "command" => 88,
                "data_type" => 2,
                "reserved" => 0
              },
              "header" => %{
                "bcc" => "K",
                "company_id" => <<76, 83, 73, 83, 45, 88, 71, 84, 0, 0>>,
                "cpu_info" => 160,
                "invoke_id" => <<0, 1>>,
                "length" => 22,
                "module_position" => %{
                  "module_base" => <<0::size(4)>>,
                  "module_slot" => <<0::size(4)>>
                },
                "plc_info" => 0,
                "source_of_frame" => 51
              }
            }
  mariadb custom:
    data:
      address:
        input: true
        required: true
        type: "string"
      database:
        input: true
        required: true
        type: "text"
      password:
        input: true
        required: true
        type: "text"
      port:
        input: true
        required: true
        type: "number"
      username:
        input: true
        required: true
        type: "text"
    function:
      error:
        logic:
          $action: "elixir"
          value: |
            (Log.warn("mariadb: action: error: v: " <> inspect(v))
              emit("error", v |> Map.put("error", "Unknown packet"))
            )
      init:
        logic:
          $action: "elixir"
          value: |
            (Log.info("mariadb: action: init: v: " <> inspect(v))
              set("tid", 0)
            )
      mariadb_received:
        logic:
          $action: "elixir"
          value: |
            (Log.info("mariadb: action: received: v: " <> inspect(v))
              emit("received", v)
            )
      read_tag:
        logic:
          $action: "elixir"
          value: |
            Log.info("mariadb: function: read_tag: v: " <> inspect(v))
            table = v["_condition"]["table"]
            if (table && (table != "")) do
              column = if (v["_condition"]["column"] && (v["_condition"]["column"] != "")), do: v["_condition"]["column"], else: "*"
              condition = if (v["_condition"]["condition"] && (v["_condition"]["condition"] != "")), do: " WHERE " <> v["_condition"]["condition"], else: ""
              query = "SELECT " <> column <> " FROM " <> table <> condition
              result = case instance("client", "query", query) do
                {:ok, response} ->
                  case response do
                    %Mariaex.Result{columns: [_column], num_rows: 1, rows: [[x]]} -> {:ok, x}
                    %Mariaex.Result{num_rows: 1, rows: [rows]} -> {:ok, rows}
                    %Mariaex.Result{rows: rows} -> {:ok, rows}
                    _ -> {:ok, response}
                  end
                response -> response
              end
              Log.info("mariadb: function: read_tag: result: " <> inspect(result))
              result
            else
              ""
            end
      write_tag:
        logic:
          $action: "elixir"
          value: |
            Log.info("mariadb: function: write_tag: v: " <> inspect(v))
            table = v["properties"]["_condition"]["table"]
            if (table && (table != "")) do
              column = if (v["properties"]["_condition"]["column"] && (v["properties"]["_condition"]["column"] != "")), do: v["properties"]["_condition"]["column"], else: "*"
              condition = if (v["properties"]["_condition"]["condition"] && (v["properties"]["_condition"]["condition"] != "")), do: " WHERE " <> v["properties"]["_condition"]["condition"], else: ""
              set_string = cond do
                is_list(v["value"]) ->
                  column |> String.split(",") |> Enum.with_index |> Enum.map(fn {x, i} ->
                    if (Enum.at(v["value"], i)), do: x <> "= '" <> Enum.at(v["value"], i) <> "'", else: ""
                  end) |> Enum.join(", ")
                is_binary(v["value"]) ->
                  val = v["value"] |> String.split(",")
                  column |> String.split(",") |> Enum.with_index |> Enum.map(fn {x, i} ->
                    x <> "= '" <> Enum.at(val, i) <> "'"
                  end) |> Enum.join(", ")
                is_number(v["value"]) ->
                  column |> String.split(",") |> Enum.with_index |> Enum.map(fn {x, i} ->
                    x <> "= " <> inspect(v["value"])
                  end) |> Enum.join(", ")
                true ->
                  column |> String.split(",") |> Enum.with_index |> Enum.map(fn {x, i} ->
                    x <> "= '" <> inspect(v["value"]) <> "'"
                  end) |> Enum.join(", ")
              end
              Log.info("mariadb: function: write_tag: set_string: " <> inspect(set_string))
              query = "UPDATE " <> table <> " SET " <> set_string <> condition
              Log.info("mariadb: function: write_tag: query: " <> inspect(query))
              result = instance("client", "query", query)
              Log.info("mariadb: function: write_tag: result: " <> inspect(result))
              result
            else
              ""
            end
    instance:
      client:
        data:
          address:
            $action: "elixir"
            value: |
              address = get("address")
              Log.info("ADDRESS: " <>  inspect(address))
              address
          database:
            $action: "elixir"
            value: |
              database = get("database")
              Log.info("DATABASE: " <>  inspect(database))
              database
          password:
            $action: "elixir"
            value: |
              password = get("password")
              Log.info("PASSWORD: " <>  inspect(password))
              password
          port:
            $action: "elixir"
            value: |
              port = get("port")
              Log.info("PORT: " <>  inspect(port))
              port
          username:
            $action: "elixir"
            value: |
              username = get("username")
              Log.info("USERNAME: " <>  inspect(username))
              username
        event:
          error:
            $action: "elixir"
            value: |
              function("error", v)
               Log.info(v)
          received:
            $action: "elixir"
            value: |
              function("mariadb_received", v)
        use: "mariadb"
  modbus rtu master:
    data:
      data_bits:
        default: 0
        input: true
        type: "integer"
      framing:
        default: "none"
        input: true
        type: "string"
      framing_separator:
        default: ""
        input: true
        type: "string"
      framing_timeout:
        default: 100
        input: true
        type: "integer"
      models:
        default:
          - "modbus rtu response"
        input: true
        type: "list"
      parity:
        default: "none"
        input: true
        type: "string"
      port:
        default: ""
        input: true
        required: true
        type: "string"
      speed:
        default: 115200
        input: true
        type: "integer"
      stop_bits:
        default: 0
        input: true
        type: "integer"
    function:
      error:
        logic:
          $action: "elixir"
          value: |
            (Log.info("modbus rtu master: action: error: v: " <> inspect(v))
              emit("error", v |> Map.put("error", "Unknown packet"))
            )
      modbus_received:
        logic:
          $action: "elixir"
          value: |
            (Log.info("modbus rtu master: action: modbus_received: v: " <> inspect(v))
              emit("received", v)
            )
      read_tag:
        logic:
          $action: "elixir"
          value: |
            Log.info("modbus rtu master: function: read_tag: v: " <> inspect(v))
            tag_id = [v["_category"],v["_group"],v["_device"],v["_name"]]
            schedule_count_data = get(["scheduled_count", tag_id])
            scheduled_count = if (schedule_count_data), do: schedule_count_data, else: (set(["scheduled_count", tag_id], 0); 0)
            if (scheduled_count < 2) do
              scheduler_id = inspect System.os_time()
              set(["scheduler", scheduler_id], true)
              count(["scheduled_count", tag_id], 1)
              Log.info("modbus rtu master: function: read_tag: scheduler: " <> inspect(get(["scheduler"])))
              result = Enum.find_value(1..100000, false, fn x ->
                :timer.sleep(1)
                priority = get(["priority_scheduler"])
                priority_scheduler = if (priority), do: priority |> Map.keys(), else: []
                if (length(priority_scheduler) == 0) do
                  schedulers = get(["scheduler"]) |> Map.keys()
                  Enum.at(schedulers, 0) === scheduler_id
                else
                  false
                end
              end) |> if do
                {function_code_string, mem_address_string} = v["_condition"]["address"] |> String.split_at(1)
                function_code = case function_code_string do
                  "0" -> 1
                  "1" -> 2
                  "3" -> 4
                  "4" -> 3
                  _ -> 4
                end
                {mem_address, _} = mem_address_string |> Integer.parse()
                memory_address = if mem_address > 0, do: mem_address - 1, else: 0
                alength = v["_condition"]["length"]
                uid = get("uid")
                data = encode(%{"address" => memory_address, "length" => alength, "function" => function_code, "id" => uid}, "modbus rtu request") |> Map.get(:result)
                Log.info("modbus rtu master: function: read_tag: send: " <> inspect(data))
                instance("master", "send", data)
                result = Enum.find_value(1..2000, <<>>, fn x ->
                  :timer.sleep(1)
                  received = instance("master", "read received")
                  if (received == ""), do: false, else: received |> Map.get("value")
                end)
                clear(["scheduler", scheduler_id])
                count(["scheduled_count", tag_id], -1)
                Log.info("modbus rtu master: function: read_tag: result: " <> inspect(result))
                {:ok, result}
              else
                clear(["scheduler", scheduler_id])
                count(["scheduled_count", tag_id], -1)
                Log.warn("modbus rtu master: function: read_tag: timeout: " <> inspect(v))
                {:error, "timeout"}
              end
            else
              {:error, "queue full for tag: " <> inspect(tag_id)}
            end
      send:
        logic:
          $action: "elixir"
          value: |
            (Log.info("modbus rtu master: function: send: v: " <> inspect(v))
              instance("master", "send", encode(v, "modbus rtu request") |> Map.get(:result))
            )
      write_tag:
        logic:
          $action: "elixir"
          value: |
            scheduler_id = inspect System.os_time()
            set(["priority_scheduler", scheduler_id], true)
            Log.info("modbus rtu master: function: write_tag: priority_scheduler: " <> inspect(get(["priority_scheduler"])))
            Log.info("modbus rtu master: function: write_tag: v: " <> inspect(v))
            result = Enum.find_value(1..100000, false, fn x ->
              :timer.sleep(1)
              schedulers = get(["priority_scheduler"]) |> Map.keys()
              Enum.at(schedulers, 0) === scheduler_id
            end) |> if do
              {function_code_string, mem_address_string} = v["properties"]["_condition"]["address"] |> String.split_at(1)
              function_code = case function_code_string do
                "0" -> 5
                "4" -> 6
                _ -> -1
              end
              if (function_code) do
                {mem_address, _} = mem_address_string |> Integer.parse()
                memory_address = if mem_address > 0, do: mem_address - 1, else: 0
                value = v["value"]
                uid = get("uid")
                data = encode(%{"address" => memory_address, "length" => value, "function" => function_code, "id" => uid}, "modbus rtu request") |> Map.get(:result)
                Log.info("modbus rtu master: function: write_tag: send: " <> inspect(data))
                instance("master", "send", data)
                result = Enum.find_value(1..2000, <<>>, fn x ->
                  :timer.sleep(1)
                  received = instance("master", "read received")
                  if (received == ""), do: false, else: received |> Map.get("value")
                end)
                clear(["priority_scheduler", scheduler_id])
                Log.info("modbus rtu master: function: write_tag: result: " <> inspect(result))
                {:ok, result}
              else
                clear(["priority_scheduler", scheduler_id])
                Log.warn("modbus rtu master: function: write_tag: unknown function_code: " <> inspect(function_code))
                {:error, "unknown function_code: " <> inspect(function_code)}
              end
            else
              clear(["priority_scheduler", scheduler_id])
              Log.warn("modbus rtu master: function: write_tag: timeout: " <> inspect(v))
              {:error, "timeout"}
            end
    instance:
      master:
        data:
          data_bits:
            $action: "elixir"
            value: |
              get("data_bits")
          framing:
            $action: "elixir"
            value: |
              get("framing")
          framing_separator:
            $action: "elixir"
            value: |
              get("framing_separator")
          framing_timeout:
            $action: "elixir"
            value: |
              get("framing_timeout")
          models:
            $action: "elixir"
            value: |
              get("models")
          parity:
            $action: "elixir"
            value: |
              get("parity")
          port:
            $action: "elixir"
            value: |
              get("port")
          speed:
            $action: "elixir"
            value: |
              get("speed")
          stop_bits:
            $action: "elixir"
            value: |
              get("stop_bits")
        event:
          error:
            $action: "elixir"
            value: |
              function("error", v)
              Log.warn("modbus rtu master: error: " <> inspect(v))
          modbus rtu response:
            $action: "elixir"
            value: |
              Log.info("modbus rtu master: response: " <> inspect(v))
              # function("modbus_received", v)
          received:
            $action: "elixir"
            value: |
              Log.info("modbus rtu master: received: " <> inspect(v))
              # function("modbus_received", v)
        use: "serial"
    model:
      modbus rtu header:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "id"
            options:
              units: "bytes"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "function"
            options:
              units: "bytes"
            size: 1
            type: "integer"
      modbus rtu request:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "modbus rtu header"
            overrides: {}
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "address"
            options:
              units: "bytes"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "length"
            options:
              units: "bytes"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "crc"
            options:
              endianness: "little"
              mode: "crc_16_modbus"
            size:
              value: 0
            type: "crc"
        testInput:
          encode: |
            %{
            "ID" => 1,
            "function" => 2,
            "address" => 3,
            "length" => 4
            }
      modbus rtu response:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "modbus rtu header"
            overrides: {}
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "count"
            options:
              units: "bytes"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "value"
            options: {}
            size:
              $action: "elixir"
              value: |
                v["count"]
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "crc"
            options:
              endianness: "little"
              mode: "crc_16_modbus"
            type: "crc"
        testInput:
          encode: |
            %{
            "ID" => 1,
            "function" => 2,
            "count" => 3,
            "value" => <<4,4,4>>
            }
  modbus tcp master:
    data:
      address:
        input: true
        required: true
        type: "string"
      port:
        input: true
        required: true
        type: "number"
      uid:
        default: 255
        input: true
        required: true
        type: "number"
    function:
      error:
        logic:
          $action: "elixir"
          value: |
            (Log.warn("modbus master: action: error: v: " <> inspect(v))
              emit("error", v |> Map.put("error", "Unknown packet"))
            )
      init:
        logic:
          $action: "elixir"
          value: |
            (Log.info("modbus slave: action: init: v: " <> inspect(v))
              set("tid", 0)
            )
      modbus_received:
        logic:
          $action: "elixir"
          value: |
            (Log.info("modbus master: action: modbus_received: v: " <> inspect(v))
              emit("received", v)
            )
      read_tag:
        logic:
          $action: "elixir"
          value: |
            Log.info("modbus master: function: read_tag: v: " <> inspect(v))
            # result = instance("client", "send", data)
            {function_code_string, mem_address_string} = v["_condition"]["address"] |> String.split_at(1)
            function_code = case function_code_string do
              "0" -> 1
              "1" -> 2
              "3" -> 4
              "4" -> 3
              _ -> 4
            end
            {mem_address, _} = mem_address_string |> Integer.parse()
            memory_address = if mem_address > 0, do: mem_address - 1, else: 0
            alength = v["_condition"]["length"]
            address = get("address")
            port = get("port")
            uid = get("uid")
            data = encode(%{"address" => memory_address, "alength" => alength, "function" => function_code, "plength" => 6, "tid" => 1, "uid" => uid}, "modbus tcp request") |> Map.get(:result)
            Log.info("modbus master: function: read_tag: data: " <> inspect(data))
            result = Service.Tcp.send_and_recv(address, port, data) |> case do
              {:ok, ret} -> {:ok, ret |> decode("modbus tcp response") |> Map.get(:result) |> Map.get("value")}
              _ -> {:error, %{}}
            end
            Log.info("modbus master: function: read_tag: result: " <> inspect(result))
            result
      send:
        logic:
          $action: "elixir"
          value: |
            (Log.info("modbus master: function: send: v: " <> inspect(v))
              instance("client", "send", encode(v, "modbus tcp request") |> Map.get(:result))
            )
      write_tag:
        logic:
          $action: "elixir"
          value: |
            Log.info("modbus master: function: write_tag: v: " <> inspect(v))
            {function_code_string, mem_address_string} = v["properties"]["_condition"]["address"] |> String.split_at(1)
            function_code = case function_code_string do
              "0" -> 5
              "4" -> 16
              _ -> -1
            end
            if (function_code) do
              {mem_address, _} = mem_address_string |> Integer.parse()
              memory_address = if mem_address > 0, do: mem_address - 1, else: 0
              address = get("address")
              port = get("port")
              uid = get("uid")
              address_count = v["properties"]["_condition"]["length"]
              size = address_count * 16
              value = v["value"]
              alength = cond do
                is_integer(value) -> <<value::size(size)>>
                is_float(value) ->
                  case address_count do
                    2 -> <<value::float-size(size)>>
                    4 -> <<value::float-size(size)>>
                    _ ->
                      value_tmp = value |> trunc()
                      <<value_tmp::size(size)>>
                  end
                is_binary(value) ->
                  if (byte_size(value) <= (address_count * 2)) do
                    value |> String.pad_leading(address_count * 2, <<0>>)
                  else
                    value |> :binary.part(byte_size(value), -(address_count * 2))
                  end
                true -> <<0::size(size)>>
              end
              data = encode(%{"address" => memory_address, "alength" => alength, "function" => function_code, "address_count" => address_count, "tid" => 1, "uid" => uid}, "modbus tcp write request") |> Map.get(:result)
              Log.info("modbus master: function: write_tag: data: " <> inspect(data))
              result = Service.Tcp.send_and_recv(address, port, data) |> case do
                {:ok, ret} -> {:ok, ret |> decode("modbus tcp response") |> Map.get(:result) |> Map.get("value")}
                _ -> {:error, %{}}
              end
              Log.info("modbus master: function: write_tag: result: " <> inspect(result))
              result
            end
    instance:
      client:
        data:
          address:
            $action: "elixir"
            value: |
              get("address")
          port:
            $action: "elixir"
            value: |
              get("port")
        event:
          error:
            $action: "elixir"
            value: |
              function("error", v)
               Log.warn("modbus tcp master: error: " <> inspect(v))
          received:
            $action: "match"
            key:
              - "data"
            matches:
              - do:
                  $action: "elixir"
                  value: |
                    function("modbus_received", v)
                model:
                  $ref: "modbus tcp response"
            none:
              $action: "elixir"
              value: |
                Log.info("modbus tcp master: received: unknown data: " <> inspect(v))
        use: "tcp client"
    model:
      modbus tcp header:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tid"
            options:
              units: "bytes"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "pid"
            options:
              units: "bytes"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "plength"
            options:
              units: "bytes"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "uid"
            options:
              units: "bytes"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "function"
            options:
              units: "bytes"
            size: 1
            type: "integer"
      modbus tcp request:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "modbus tcp header"
            overrides:
              plength:
                default: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "address"
            options:
              units: "bytes"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "alength"
            options:
              units: "bytes"
            size: 2
            type: "integer"
        parser: "binary"
      modbus tcp write request:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "modbus tcp header"
            overrides:
              plength:
                value:
                  $action: "elixir"
                  value: |
                    (v["blength"] + 7)
            requires: "blength"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "address"
            options:
              units: "bytes"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "address_count"
            options:
              units: "bytes"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "blength"
            options:
              units: "bytes"
            size: 1
            type: "integer"
            value:
              $action: "elixir"
              value: |
                v["address_count"] * 2
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "alength"
            size:
              $action: "elixir"
              value: |
                v["blength"]
            type: "bytes"
        parser: "binary"
        testInput:
          decode: "<<0,1,0,2,0,3,4,5,0,6,0,7>>"
          encode: "%{\"address\" => 0, \"alength\" => 123124112324, \"function\" => 16, \"address_count\" => 2, \"tid\" => 1, \"uid\" => 1}"
      modbus tcp response:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "modbus tcp header"
            overrides:
              plength:
                default:
                  $action: "elixir"
                  value: |
                    (
                      Log.info("modbus tcp response: overrides: plength: default: v: " <> inspect(v))
                      3
                    )
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "count"
            options:
              units: "bytes"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "value"
            options: {}
            size:
              $action: "elixir"
              value: |
                v["count"]
            type: "bytes"
  modbus tcp slave:
    data:
      mem:
        type: "string"
      port:
        type: "number"
      uids:
        type: "string"
    function:
      error:
        logic:
          $action: "elixir"
          value: |
            (Log.warn("modbus slave: action: error: v: " <> inspect(v))
              emit("error", v |> Map.put("error", "Unknown packet"))
            )
      get:
        logic:
          $action: "elixir"
          value: |
            (Log.info("modbus slave: action: get: v: " <> inspect(v))
              get(v["path"])
            )
      init:
        logic:
          $action: "elixir"
          value: |
            (Log.info("modbus slave: action: init: v: " <> inspect(v))
              buf_size = 16 * 65536
              default_mem = %{
                "coil" => <<0::size(buf_size)>>,
                "discrete" => <<0::size(buf_size)>>,
                "input" => <<0::size(buf_size)>>,
                "holding" => <<0::size(buf_size)>>
              }
              mem_ids = v["uids"] |> String.split(",") |> Enum.reduce(%{}, fn x, acc ->
                acc |> Map.put(x |> String.trim(), default_mem)
              end)
              Log.info("modbus slave: action: init: mem_ids: " <> inspect(mem_ids))
              set("mem", mem_ids, flatten: true)
            )
      modbus_received:
        logic:
          $action: "elixir"
          value: |
            (Log.info("modbus slave: action: modbus_received: v: " <> inspect(v))
              # modbus slave: action: modbus_received: v: %{"connection_info" => "192.168.51.201:55843", "data" => %{"address" => 0, "alength" => 1, "function" => 4, "pid" => 0, "plength" => 6, "tid" => 87, "uid" => 1},
              [
                {1, "coil", "read"},
                {2, "discrete", "read"},
                {3, "holding", "read"},
                {4, "input", "read"},
                {5, "coil", "write single"},
                {6, "holding", "write single"},
                {15, "coil", "write multiple"},
                {16, "holding", "write multiple"}
              ] |> Enum.find(fn {x, _y, _z} ->
                v["data"]["function"] == x
              end) |> case do
                {function, type, "read"} ->
                  Log.info("modbus slave: action: modbus_received: action: " <> inspect({function, type, "read"}))
                  header_size = v["data"]["address"] * 16
                  data_size = v["data"]["alength"] * 16
                  <<_header::size(header_size), data::size(data_size), _rest::binary>> = get(["mem", v["data"]["uid"] |> to_string(), type])
                  count = v["data"]["alength"] * 2
                  plength = count + 3
                  packet_map = %{
                    "count" => count,
                    "function" => function,
                    "plength" => plength,
                    "tid" => v["data"]["tid"],
                    "uid" => v["data"]["uid"],
                    "value" => <<data::size(data_size)>>
                  }
                  encode_result = encode(packet_map, "modbus tcp response")
                  Log.info("modbus slave: action: modbus_received: encode_result: " <> inspect(encode_result))
                  binary_data = encode_result |> Map.get(:result)
                  Log.info("modbus slave: action: modbus_received: binary_data: " <> inspect(binary_data))
                  respond(binary_data)
                {function, type, "write single"} ->
                  Log.info("modbus slave: action: modbus_received: action: " <> inspect({function, type, "write single"}))
                  header_size = v["data"]["address"] * 16
                  data_size = 16
                  value = v["data"]["alength"] # alength holds data for single writes
                  <<header::size(header_size), data::size(data_size), rest::binary>> = get(["mem", v["data"]["uid"] |> to_string, type])
                  set(["mem", v["data"]["uid"] |> to_string, type], <<header::size(header_size), value::size(data_size), rest::binary>>)
                  Log.info("modbus slave: action: modbus_received: data: " <> inspect(data))
                  Log.info("modbus slave: action: modbus_received: value: " <> inspect(value))
                  emit("write", v |> Map.put("value", v["data"]["alength"]) |> Map.put("idFields", [v["data"]["uid"], type, v["data"]["address"]]))
                  packet_map = v["data"]
                  encode_result = encode(packet_map, "modbus tcp request") # response of single write has the same format as request
                  binary_data = encode_result |> Map.get(:result)
                  Log.info("modbus slave: action: modbus_received: respond: binary_data: " <> inspect(binary_data))
                  respond(binary_data)
                error ->
                  Log.info("modbus slave: action: modbus_received: error: " <> inspect(error))
                  # TODO: Send error response
                  # packet_map = %{
                  #   "count" => count,
                  #   "function" => function,
                  #   "plength" => plength,
                  #   "tid" => v["data"]["tid"],
                  #   "uid" => v["data"]["uid"],
                  #   "value" => <<data::size(data_size)>>
                  # }
              end
            )
      respond:
        logic:
          $action: "elixir"
          value: |
            (Log.info("modbus slave: respond: v: " <> inspect(v))
              respond(encode(v, "modbus tcp response") |> Map.get(:result))
            )
      send:
        logic:
          $action: "elixir"
          value: |
            (Log.info("modbus slave: send: v: " <> inspect(v))
              instance("server", "send", encode(v, "modbus tcp response") |> Map.get(:result))
            )
      set:
        logic:
          $action: "elixir"
          value: |
            (Log.info("modbus slave: action: get: v: " <> inspect(v))
              set(v["path"], v["value"], flatten: true)
            )
      starting:
        logic:
          $action: "elixir"
          value: |
            Log.info("modbus slave: action: starting: v: " <> inspect(v))
            function("init", v)
            emit("starting", v)
      write_mem:
        logic:
          $action: "elixir"
          value: |
            (Log.info("modbus slave: function: write_mem: v: " <> inspect(v))
              [uid, type, address] = v["tag"]["idFields"]
              header_size = address * 16
              data_size = byte_size(v["bin"]) * 8
              insert_size = if (data_size < 16), do: 16, else: data_size
              <<header::size(header_size), _data::size(insert_size), rest::binary>> = get(["mem", uid |> to_string, type])
              cond do
                is_integer(v["value"]) && (v["value"] < 0) ->
                  <<value::signed-integer-size(data_size)>> = v["bin"]
                  set(["mem", uid |> to_string, type], <<header::size(header_size), value::signed-integer-size(insert_size), rest::binary>>)
                true ->
                  <<value::size(data_size)>> = v["bin"]
                  set(["mem", uid |> to_string, type], <<header::size(header_size), value::size(insert_size), rest::binary>>)
              end
            )
    instance:
      server:
        data:
          port:
            $action: "elixir"
            value: |
              get("port")
        event:
          error:
            $action: "elixir"
            value: |
              function("error", v)
              Log.info("modbus slave: error: " <> inspect(v))
          received:
            $action: "match"
            key:
              - "data"
            matches:
              - do:
                  $action: "elixir"
                  value: |
                    Log.info("modbus tcp slave: request: received: " <>inspect(v))
                    function("modbus_received", v)
                model:
                  $ref: "modbus tcp request"
            none:
              $action: "elixir"
              value: |
                Log.info("modbus tcp slave: received: unknown data: " <> inspect(v))
        use: "tcp server"
    model:
      modbus tcp header:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "tid"
            options:
              units: "bytes"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "pid"
            options:
              units: "bytes"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "plength"
            options:
              units: "bytes"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "uid"
            options:
              units: "bytes"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "function"
            options:
              units: "bytes"
            size: 1
            type: "integer"
      modbus tcp request:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "modbus tcp header"
            overrides:
              plength:
                default: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "address"
            options:
              units: "bytes"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "alength"
            options:
              units: "bytes"
            size: 2
            type: "integer"
        testInput:
          decode: "<<0,1,0,2,0,3,4,5,0,6,0,7>>"
      modbus tcp response:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "modbus tcp header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "count"
            options:
              units: "bytes"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "value"
            options: {}
            size:
              $action: "elixir"
              value: |
                v["count"]
            type: "bytes"
  melsec ethernet:
    data:
      address:
        input: true
        required: true
        type: "string"
      port:
        input: true
        required: true
        type: "number"
      response:
        default: ""
    function:
      read_tag:
        logic:
          $action: "elixir"
          value: |
            Log.info("melsec ethernet: function: read_tag: v: " <> inspect(v))
            tag_id = [v["_category"],v["_group"],v["_device"],v["_name"]]
            schedule_count_data = get(["scheduled_count", tag_id])
            scheduled_count = if (schedule_count_data), do: schedule_count_data, else: (set(["scheduled_count", tag_id], 0); 0)
            if (scheduled_count < 2) do
              scheduler_id = inspect System.os_time()
              set(["scheduler", scheduler_id], true)
              count(["scheduled_count", tag_id], 1)
              Log.info("melsec ethernet: function: read_tag: scheduler: " <> inspect(get(["scheduler"])))
              result = Enum.find_value(1..100000, false, fn x ->
                :timer.sleep(1)
                priority = get(["priority_scheduler"])
                priority_scheduler = if (priority), do: priority |> Map.keys(), else: []
                if (length(priority_scheduler) == 0) do
                  schedulers = get(["scheduler"]) |> Map.keys()
                  Enum.at(schedulers, 0) === scheduler_id
                else
                  false
                end
              end) |> if do
                address = get("address")
                port = get("port")
                io_number = get("io_number")
                plc_number = get("plc_number")
                station_number = get("station_number")
                network_number = get("network_number")
                communication_type = get("communication_type")

                {key, offset, data_type} = function("parse_tag_data", {v["_condition"]["address"], communication_type})
                read_count = v["_condition"]["length"]

                header = %{
                  "num_IO" => io_number,
                  "num_network" => network_number,
                  "num_plc" => plc_number,
                  "num_station" => station_number,
                  "sub_header" => "5000",
                  "data_length" => (if communication_type === "ASCII", do: "0018", else: "000C"),
                  "cpu_timer" => "0010"
                 }

                data_tmp = (if communication_type === "ASCII" do
                 %{
                  "body" => %{
                    "device_code" => key,
                    "num_device_point" => read_count |> Integer.to_string(16) |> String.pad_leading(4, "0"),
                    "num_head_device" => offset
                  },
                  "header" => header
                 }
                else
                 %{
                  "body" => %{
                    "device_code" => key,
                    "num_device_point" => read_count,
                    "num_head_device" => offset |> String.to_integer
                  },
                  "header" => header |> Enum.map(fn {k,v} -> {k,v |> String.to_integer(16)} end) |> Map.new
                 }
                end)
                data = encode(data_tmp, ("read_variable_" <> data_type <> "_" <> communication_type)).result
                Log.info(data)

                instance("client", "send", data)
                result = Enum.find_value(1..20, <<>>, fn x ->
                  :timer.sleep(100)
                  decoded = function("read_tag_match_" <> data_type, get("response"))
                  Log.info("melsec ethernet return: " <> inspect(decoded))
                  if (decoded == ""), do: false, else: decoded
                end) |> case do
                  <<>> ->
                    Log.warn("melsec ethernet: function: read_tag: timeout:")
                    {:error, "timeout"}
                  received ->
                    ret = received |> Map.get("block_data_" <> communication_type)
                    Log.info("melsec ethernet: function: read_tag: result: " <> inspect(ret))
                    ret_parsed = if (data_type === "bit") do
                      tmp_data = :binary.bin_to_list(ret)
                      len = (tmp_data |> length) -1
                      for n <- 0..len do
                        data = tmp_data |> Enum.at(n) |> Integer.to_string(16)
                        if n == len and (rem(read_count, 2) == 1), do: data, else: data |> String.pad_trailing(2, "0")
                      end |> Enum.reduce(fn x, acc -> acc <> x end)
                    else
                      ret |> Enum.map(fn x -> x |> Map.values |> Enum.at(0) |> :binary.decode_unsigned |> Integer.to_string(16) |> String.pad_leading(4, "0")  end)
                          |> Enum.reduce(fn x, acc -> acc <> x end)
                    end
                    {:ok, ret_parsed}
                  {:NAK, err} ->
                    ret = err |> Map.get("exit_code")
                    Log.info("melsec ethernet: function: read_tag: result: " <> inspect(ret))
                    {:error, ret}
                end
                clear(["scheduler", scheduler_id])
                count(["scheduled_count", tag_id], -1)
                result
              else
                clear(["scheduler", scheduler_id])
                count(["scheduled_count", tag_id], -1)
                Log.warn("melsec ethernet: function: read_tag: timeout: " <> inspect(v))
                {:error, "timeout"}
              end
            else
              {:error, "queue full for tag: " <> inspect(tag_id)}
            end
        testInput:
          default: |
            %{
              "_condition" => %{
                "address" => "M*",
                "data_type" => "bit",
                "offset" => 100,
                "length" => 8
              }
            }
      read_tag_match_bit:
        logic:
          $action: "match"
          matches:
            - do:
                $action: "elixir"
                value: |
                  Log.info("read_variable_bit_ACK_ASCII")
                  data = v
                  Log.info("match: " <> inspect(data))
                  set("response", "")
                  data
              model:
                $ref: "read_variable_bit_ACK_ASCII"
            - do:
                $action: "elixir"
                value: |
                  Log.info("read_variable_bit_ACK_binary")
                  data = v
                  Log.info("match: " <> inspect(data))
                  set("response", "")
                  data
              model:
                $ref: "read_variable_bit_ACK_binary"
            - do:
                $action: "elixir"
                value: |
                  Log.info("NAK_ASCII")
                  data = v
                  Log.info("match: " <> inspect(data))
                  set("response", "")
                  {:NAK, data}
              model:
                $ref: "NAK_ASCII"
            - do:
                $action: "elixir"
                value: |
                  Log.info("NAK_binary")
                  data = v
                  Log.info("match: " <> inspect(data))
                  set("response", "")
                  {:NAK, data}
              model:
                $ref: "NAK_binary"
          none:
            $action: "elixir"
            value: |
               Log.info("none: " <> inspect(v))
               ""
      read_tag_match_word:
        logic:
          $action: "match"
          matches:
            - do:
                $action: "elixir"
                value: |
                  Log.info("read_variable_word_ACK_ASCII")
                  data = v
                  Log.info("match: " <> inspect(data))
                  set("response", "")
                  data
              model:
                $ref: "read_variable_word_ACK_ASCII"
            - do:
                $action: "elixir"
                value: |
                  Log.info("read_variable_word_ACK_binary")
                  data = v
                  Log.info("match: " <> inspect(data))
                  set("response", "")
                  data
              model:
                $ref: "read_variable_word_ACK_binary"
            - do:
                $action: "elixir"
                value: |
                  Log.info("NAK_ASCII")
                  data = v
                  Log.info("match: " <> inspect(data))
                  set("response", "")
                  {:NAK, data}
              model:
                $ref: "NAK_ASCII"
            - do:
                $action: "elixir"
                value: |
                  Log.info("NAK_binary")
                  data = v
                  Log.info("match: " <> inspect(data))
                  set("response", "")
                  {:NAK, data}
              model:
                $ref: "NAK_binary"
          none:
            $action: "elixir"
            value: |
               Log.info("none: " <> inspect(v))
               ""
      write_tag:
        logic:
          $action: "elixir"
          value: |
            Log.info("melsec ethernet: function: write_tag: v: " <> inspect(v))
            scheduler_id = inspect System.os_time()
            set(["priority_scheduler", scheduler_id], true)
            result = Enum.find_value(1..100000, false, fn x ->
              :timer.sleep(1)
              schedulers = get(["priority_scheduler"]) |> Map.keys()
              Enum.at(schedulers, 0) === scheduler_id
            end) |> if do
                address = get("address")
                port = get("port")
                io_number = get("io_number")
                plc_number = get("plc_number")
                station_number = get("station_number")
                network_number = get("network_number")
                communication_type = get("communication_type")
                Log.info("write_tag: function: " <> inspect(v))
                {key, offset, data_type} = function("parse_tag_data", {v["properties"]["_condition"]["address"], communication_type})
                Log.info("write_tag: function: key:" <> inspect(key))
                write_count = v["properties"]["_condition"]["length"]
                data_length = ({communication_type, data_type} |> case do
                 {"binary", "bit"} -> 12 + (write_count/2 |> trunc)
                 {"binary", "word"} -> 12 + (write_count * 2)
                 {"ASCII", "bit"} -> 24 + write_count
                 {"ASCII", "word"} -> 24 + (write_count * 4)
                end) |> Integer.to_string(16) |> String.pad_leading(4,"0000")
                Log.info("write_tag: function: write_count:" <> inspect(write_count))
                write_data = {communication_type, data_type} |> case do
                 {"binary", "bit"} ->
                   v["value"]
                   |> String.codepoints
                   |> Enum.chunk(2)
                   |> Enum.map(&Enum.join/1)
                   |> Enum.reduce(0, fn x, acc ->  acc + String.to_integer(x,16) end)
                 {"binary", "word"} ->
                   v["value"]
                   |> String.codepoints
                   |> Enum.chunk(4)
                   |> Enum.map(&Enum.join/1)
                   |> Enum.map(fn x -> %{"data" => String.to_integer(x, 16)} end)
                 {"ASCII", "bit"} ->
                   v["value"]
                 {"ASCII", "word"} ->
                   v["value"]
                   |> String.codepoints
                   |> Enum.chunk(4)
                   |> Enum.map(&Enum.join/1)
                   |> Enum.map(fn x -> %{"data" => x} end)
                end
                Log.info("melsec ethernet: function: write_tag: write_data: " <> inspect(write_data))

                header = %{
                  "num_IO" => io_number,
                  "num_network" => network_number,
                  "num_plc" => plc_number,
                  "num_station" => station_number,
                  "sub_header" => "5000",
                  "data_length" => data_length,
                  "cpu_timer" => "0010"
                 }
                Log.info("melsec ethernet: function: write_tag: header: " <> inspect(write_data))
                data_tmp = (if communication_type === "ASCII" do
                 %{
                  "block_device" => %{
                    "device_code" => key,
                    "num_device_point" => write_count |> Integer.to_string(16) |> String.pad_leading(4, "0"),
                    "num_head_device" => offset
                  },
                  "header" => header,
                  "block_data" => %{ "data" => write_data  }
                 }
                else
                 %{
                  "block_device" => %{
                    "device_code" => key,
                    "num_device_point" => write_count,
                    "num_head_device" => offset |> String.to_integer
                  },
                  "header" => (header |> Enum.map(fn {k,v} -> {k,v |> String.to_integer(16)} end) |> Map.new),
                  "block_data" => write_data
                 }
                end)
                Log.info("melsec ethernet: test: " <> inspect(data_tmp))
                data = encode(data_tmp, ("write_variable_" <> data_type <> "_" <> communication_type)).result
                Log.info("melsec ethernet: function: write_tag: data: " <> inspect(data))
                instance("client", "send", data)

                result = Enum.find_value(1..20, <<>>, fn x ->
                  :timer.sleep(100)
                  Log.info("melsec ethernet: function: write_tag: return: " <> inspect(get("response")))
                  decoded = function("write_tag_match", get("response"))
                  Log.info("melsec ethernet: function: write_tag: return: " <> inspect(decoded))
                  if (decoded == ""), do: false, else: decoded
                end) |> case do
                  <<>> ->
                    Log.warn("melsec ethernet: function: write_tag: timeout:")
                    {:error, "timeout"}
                  received ->
                    ret = received |> Map.get("block_data_" <> communication_type)
                    Log.info("melsec ethernet: function: write_tag: result: " <> inspect(ret))
                    {:ok, ret}
                  {:NAK, err} ->
                    ret = err |> Map.get("exit_code")
                    Log.info("melsec ethernet: function: write_tag: result: " <> inspect(ret))
                    {:error, ret}
                end
                clear(["priority_scheduler", scheduler_id])
                result
            else
              clear(["priority_scheduler", scheduler_id])
              Log.warn("cnet: function: write_tag: timeout: " <> inspect(v))
              {:error, "timeout"}
            end
        testInput:
          default: |
            %{
                "properties" => %{
                  "_condition" => %{
                    "address" => "M*",
                    "data_type" => "bit",
                    "offset" => 100,
                    "length" => 8
                  }
               },
              "value" => 255
            }
      write_tag_match:
        logic:
          $action: "match"
          matches:
            - do:
                $action: "elixir"
                value: |
                  Log.info("write_ACK_ASCII")
                  data = v
                  Log.info("match: " <> inspect(data))
                  set("response", "")
                  data
              model:
                $ref: "write_ACK_ASCII"
            - do:
                $action: "elixir"
                value: |
                  Log.info("write_ACK_binary")
                  data = v
                  Log.info("match: " <> inspect(data))
                  set("response", "")
                  data
              model:
                $ref: "write_ACK_binary"
            - do:
                $action: "elixir"
                value: |
                  Log.info("NAK_ASCII")
                  data = v
                  Log.info("match: " <> inspect(data))
                  set("response", "")
                  {:NAK, data}
              model:
                $ref: "NAK_ASCII"
            - do:
                $action: "elixir"
                value: |
                  Log.info("NAK_binary")
                  data = v
                  Log.info("match: " <> inspect(data))
                  set("response", "")
                  {:NAK, data}
              model:
                $ref: "NAK_binary"
          none:
            $action: "elixir"
            value: |
               Log.info("none: " <> inspect(v))
      parse_tag_data:
        logic:
          $action: "elixir"
          value: |
            { address, communication_type } = { v |> elem(0) |>  String.replace([" ", "*"], ""), v |> elem(1)}
            # separate key and offset
            { key, offset } = {address |> String.slice(0, 1), address |> String.slice(1, address |> byte_size)}

            device_parse_map = %{
             "bit" => %{ "X" => "9C", "Y" => "9D", "M" => "90", "SM" => "91", "L" => "92", "F" => "93",
                    "V" => "94", "B" => "A0", "TS" => "C1", "TC" => "C0", "SS" => "C7", "SC" => "C6",
                    "CS" => "C4", "CC" => "C3", "SB" => "A1", "DX" => "A2", "DY" => "A3"},
             "word" => %{ "D" => "A8", "W" => "B4",  "SD" => "A9", "TN" => "C2", "SN" => "C8", "CN" => "C5",
                    "SW" => "B5", "Z" => "CC", "R" => "AF", "ZR" => "B0"}
            }

            data_type = cond do
              Enum.member?(device_parse_map["bit"] |> Map.keys , key) ->
                "bit"
              Enum.member?(device_parse_map["word"] |> Map.keys, key) ->
                "word"
              true ->
                :none
               end

            parsed_key = if communication_type === "binary" do
             device_parse_map[data_type] |> Map.get(key) |> String.to_integer(16)
            else
             key |> String.pad_trailing(2, "*")
            end
            {parsed_key, offset |> String.pad_leading(6, "0"), data_type}
    instance:
      client:
        data:
          address:
            $action: "elixir"
            value: |
              get("address")
          port:
            $action: "elixir"
            value: |
              get("port")
        event:
          connected:
            $action: "elixir"
            value: |
              Log.info("connected")
          disconnected:
            $action: "elixir"
            value: |
              Log.info("disconnected")
          received:
            $action: "elixir"
            value: |
              Log.info("received:" <> inspect(v))
              response = get("response")
              data = v |> Map.get("data")
              result = (cond do
                response === nil ->
                 data
                response !== "" ->
                 response <> data
                true ->
                 data
               end)
              set("response", result)
              Log.info("set: "<> inspect(get("response")))
        use: "tcp client"
    model:
      NAK_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "sub_header"
            size: 2
            type: "integer"
            value: 53248
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "access_num_network_access"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 255
            name: "access_num_plc_access"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 1023
            name: "access_num_IO"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "access_num_station"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 24
            name: "access_data_length"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 49233
            name: "access_exit_code"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "error_num_network_response"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 255
            name: "error_num_plc_response"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 1023
            name: "error_num_IO"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "error_num_station"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_binary"
        testInput:
          decode: ""
          encode: |
            %{
            }
      block_command_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "sub_command"
            options:
              endianness: "little"
            size: 2
            type: "integer"
      block_data_write_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "data"
            options:
              endianness: "little"
            size: 1
            type: "integer"
      block_data_read_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "0"
            name: "data"
            options:
              endianness: "little"
            size: 1
            type: "bytes"
      block_device_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 100
            name: "num_head_device"
            options:
              endianness: "little"
            size: 3
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 144
            name: "device_code"
            options:
              endianness: "little"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 8
            name: "num_device_point"
            options:
              endianness: "little"
            size: 2
            type: "integer"
        testInput:
          decode: ""
          encode: "%{}"
      block_header_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 20480
            name: "sub_header"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "num_network"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 255
            name: "num_plc"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 1023
            name: "num_IO"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "num_station"
            size: 1
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 18
            name: "data_length"
            options:
              endianness: "little"
            size: 2
            type: "integer"
        parser: "binary"
        testInput:
          decode: ""
          encode: "%{}"
      loopback_test_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "request_header_binary"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_binary"
            overrides:
              command:
                value: 1561
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 5
            name: "num_loopback_data"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "ABCDE"
            name: "loopback_data"
            size:
              $action: "elixir"
              value: |
                set("3E_MC_loopback_test", v["num_loopback_data"])
                String.to_integer(v["num_loopback_data"], 16) |> Kernel.trunc()
            type: "bytes"
        parser: "binary"
        testInput:
          decode: ""
          encode: "%{}"
      loopback_test_ACK_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header"
            overrides:
              sub_header:
                value: 53248
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 0
            name: "exit_code"
            options:
              endianness: "little"
            size: 2
            type: "integer"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_loopback_data"
            options:
              endianness: "little"
            size: 2
            type: "integer"
            value:
              $action: "elixir"
              value: |
                set("3E_MC_loopback_test", v["num_loopback_data"])
                v["num_loopback_data"]
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data_loopback"
            size:
              $action: "elixir"
              value: |
                v["num_loopback_data"]
            type: "bytes"
        testInput:
          decode: ""
          encode: "%{\"data_loopback\"=>\"ABCDE\"}"
      read_variable_bit_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "request_header_binary"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_binary"
            name: "command"
            overrides:
              command:
                value: 1025
              sub_command:
                value: 1
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device_binary"
            name: "body"
        parser: "binary"
      read_variable_bit_ACK_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "response_header_binary"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "block_data_binary"
            size:
              $action: "elixir"
              value: |
                Log.info("TT: #{inspect(v)}")
                v["data_length"] - 2
            type: "bytes"
      read_variable_word_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "request_header_binary"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_binary"
            overrides:
              command:
                value: 1025
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device_binary"
            name: "body"
        parser: "binary"
      read_variable_word_ACK_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "response_header_binary"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                (v["data_length"] - 2)/2 |> trunc
            model: "block_data_read_binary"
            name: "block_data_binary"
            overrides:
              data:
                size: 2
        parser: "binary"
      request_header_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_binary"
            overrides:
              sub_header:
                value: 20480
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 16
            name: "cpu_timer"
            options:
              endianness: "little"
            size: 2
            type: "integer"
        parser: "binary"
        testInput:
          decode: |
            "500000FF03FF0000180010"
            "500000FF03FF0000180010"
            "500000FF00000100040010"
          encode: |
            %{
              "sub_header" => "5000"
            }
      response_header_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_binary"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: 53248
            name: "exit_code"
            options:
              endianness: "little"
            size: 2
            type: "integer"
        parser: "binary"
        testInput:
          decode: "\"D00000FF03FF0000180000\""
          encode: |
            %{
              "sub_header" => "D000"
            }
      write_ACK_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "response_header_binary"
        parser: "binary"
        testInput:
          decode: "\"D00000FF03FF0000040000\""
      write_variable_bit_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "request_header_binary"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_binary"
            name: "command"
            overrides:
              command:
                value: 5121
              sub_command:
                value: 1
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device_binary"
            name: "block_device"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "block_data"
            size:
              $action: "elixir"
              value: |
                Log.info("AA: #{inspect(v)}")
                v["block_device"]["num_device_point"]/2 |> trunc
            type: "integer"
      write_variable_word_binary:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "request_header_binary"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_binary"
            overrides:
              command:
                value: 5121
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device_binary"
            name: "block_device"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["block_device"]["num_device_point"]
            model: "block_data_write_binary"
            name: "block_data"
            overrides:
              data:
                size: 2
      NAK_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "sub_header"
            size: 4
            type: "bytes"
            value: "D000"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "access_num_network_access"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "FF"
            name: "access_num_plc_access"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "03FF"
            name: "access_num_IO"
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "access_num_station"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "0018"
            name: "access_data_length"
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "C051"
            name: "access_exit_code"
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "error_num_network_response"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "FF"
            name: "error_num_plc_response"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "03FF"
            name: "error_num_IO"
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "error_num_station"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_ASCII"
        testInput:
          decode: "\"D00000FF03FF000018C05100FF03FF0000000000\""
          encode: |
            %{
              "sub_header" => "D000"
            }
      block_command_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command"
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "0000"
            name: "sub_command"
            size: 4
            type: "bytes"
      block_data_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "data"
            size: 2
            type: "bytes"
      block_device_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "M*"
            name: "device_code"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "000100"
            name: "num_head_device"
            size: 6
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "0008"
            name: "num_device_point"
            size: 4
            type: "bytes"
        testInput:
          decode: "\"M*0001000008\""
          encode: "%{}"
      block_header_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "5000"
            name: "sub_header"
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "num_network"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "FF"
            name: "num_plc"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "03FF"
            name: "num_IO"
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "num_station"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "0018"
            name: "data_length"
            size: 4
            type: "bytes"
        parser: "binary"
        testInput:
          decode: "\"500000FF03FF000000\""
          encode: "%{}"
      loopback_test_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "request_header_ASCII"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_ASCII"
            overrides:
              command:
                value: "0619"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "0005"
            name: "num_loopback_data"
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "ABCDE"
            name: "loopback_data"
            size:
              $action: "elixir"
              value: |
                set("3E_MC_loopback_test", v["num_loopback_data"], flatten: true)
                String.to_integer(v["num_loopback_data"], 16) |> Kernel.trunc()
            type: "bytes"
        parser: "binary"
        testInput:
          decode: "\"500000FF03FF0000150010061900000005ABCDE\""
          encode: "%{}"
      loopback_test_ACK_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_ASCII"
            overrides:
              sub_header:
                value: "D000"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "0000"
            name: "exit_code"
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_loopback_data"
            size: 4
            type: "bytes"
            value:
              $action: "elixir"
              value: |
                loopback_data_size = get("3E_MC_loopback_test")
                result = if loopback_data_size === nil, do: "0005", else: loopback_data_size
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "data_loopback"
            size:
              $action: "elixir"
              value: |
                String.to_integer(v["num_loopback_data"], 16) |> Kernel.trunc()
            type: "bytes"
        testInput:
          decode: "\"D00000FF000001000D00000005ABCDE\""
          encode: "%{\"data_loopback\"=>\"ABCDE\"}"
      read_variable_bit_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "request_header_ASCII"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_ASCII"
            name: "command"
            overrides:
              command:
                value: "0401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device_ASCII"
            name: "body"
        parser: "binary"
        testInput:
          decode: "\"500000FF03FF000018001004010001M*0001000008\""
          encode: |
            %{
              "header" => %{},
              "command" => %{},
              "device" => %{"num_device_point"=> "0010"}
            }
      read_variable_bit_ACK_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "response_header_ASCII"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "block_data_ASCII"
            size:
              $action: "elixir"
              value: |
                (v["data_length"] |> String.to_integer(16)) - 4
            type: "bytes"
        parser: "binary"
        testInput:
          decode: "\"D00000FF03FF00000C000000000000\""
        testOutput: {}
      read_variable_word_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "request_header_ASCII"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_ASCII"
            overrides:
              command:
                value: "0401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device_ASCII"
            name: "body"
        parser: "binary"
        testInput:
          decode: "\"500000FF03FF000018001004010000M*0001000002\""
          encode: |
            %{
             "block_device" => %{"num_device_point" => "0002"}
            }
        testOutput: {}
      read_variable_word_ACK_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "response_header_ASCII"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                ((v["data_length"] |> String.to_integer(16)) - 4)/4 |> trunc
            model: "block_data_ASCII"
            name: "block_data_ASCII"
            overrides:
              data:
                size: 4
        parser: "binary"
        testInput:
          decode: "\"D00000FF03FF00000A000000010003\""
          encode: "%{\"block_data\" => [%{\"data\" => \"0002\"}, %{\"data\" => \"0003\"} ]}"
      request_header_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_ASCII"
            overrides:
              sub_header:
                value: "5000"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "0010"
            name: "cpu_timer"
            size: 4
            type: "bytes"
        parser: "binary"
        testInput:
          decode: |
            "500000FF03FF0000180010"
            "500000FF03FF0000180010"
            "500000FF00000100040010"
          encode: |
            %{
              "sub_header" => "5000"
            }
      response_header_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_ASCII"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "5000"
            name: "exit_code"
            size: 4
            type: "bytes"
        parser: "binary"
        testInput:
          decode: "\"D00000FF03FF0000180000\""
          encode: |
            %{
              "sub_header" => "D000"
            }
      write_ACK_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "response_header_ASCII"
        testInput:
          decode: "\"D00000FF03FF0000040000\""
      write_variable_bit_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "request_header_ASCII"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_ASCII"
            name: "command"
            overrides:
              command:
                value: "1401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device_ASCII"
            name: "block_device"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_data_ASCII"
            name: "block_data"
            overrides:
              data:
                size:
                  $action: "elixir"
                  value: |
                    String.to_integer(v["block_device"]["num_device_point"], 16)
        parser: "binary"
        testInput:
          decode: "\"500000FF03FF000018001014010001M*000100000811001100\""
          encode: |
            %{
                "block_data" => %{
                  "data" => "11001100"
                }
            }
      write_variable_word_ASCII:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "request_header_ASCII"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_ASCII"
            name: "command"
            overrides:
              command:
                value: "1401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device_ASCII"
            name: "block_device"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                String.to_integer(v["block_device"]["num_device_point"], 16)
            model: "block_data_ASCII"
            name: "block_data"
            overrides:
              data:
                size: 4
        testInput:
          decode: "\"500000FF03FF000020001014010000M*00010000022347AB96\""
          encode: |
            %{
            "block_data"=> [%{"data"=> "2347"}, %{"data"=> "AB96"}],
            "block_device" =>  %{ "num_device_point"=> "0002"}
            }
  melsec serial:
    data:
      data_bits:
        default: 0
        input: true
        type: "integer"
      framing:
        default: "none"
        input: true
        type: "string"
      framing_separator:
        default: ""
        input: true
        type: "string"
      framing_timeout:
        default: 100
        input: true
        type: "integer"
      parity:
        default: "none"
        input: true
        type: "string"
      port:
        default: ""
        input: true
        required: true
        type: "string"
      speed:
        default: 9600
        input: true
        type: "integer"
      stop_bits:
        default: 0
        input: true
        type: "integer"
      format:
        default: "4F"
        input: true
        type: "string"
    function:
      parse_tag_data:
        logic:
          $action: "elixir"
          value: |
            address = v |>  String.replace([" ", "*"], "")
            # separate key and offset
            { key, offset } = {address |> String.slice(0, 1), address |> String.slice(1,  address |> byte_size)}

            device_parse_map = %{
             "bit" => %{ "X" => "9C", "Y" => "9D", "M" => "90", "SM" => "91", "L" => "92", "F" => "93",
                    "V" => "94", "B" => "A0", "TS" => "C1", "TC" => "C0", "SS" => "C7", "SC" => "C6",
                    "CS" => "C4", "CC" => "C3", "SB" => "A1", "DX" => "A2", "DY" => "A3"},
             "word" => %{ "D" => "A8", "W" => "B4",  "SD" => "A9", "TN" => "C2", "SN" => "C8", "CN" => "C5",
                    "SW" => "B5", "Z" => "CC", "R" => "AF", "ZR" => "B0"}
            }

            data_type = cond do
              Enum.member?(device_parse_map["bit"] |> Map.keys , key) ->
                "bit"
              Enum.member?(device_parse_map["word"] |> Map.keys, key) ->
                "word"
              true ->
                :none
               end

            {key |> String.pad_trailing(2, "*"), offset |> String.pad_leading(6, "0"), data_type}
      read_tag:
        logic:
          $action: "elixir"
          value: |
            Log.info("melsec serial: function: read_tag: v: " <> inspect(v))
            data_type = v["_condition"]["data_type"]
            tag_id = [v["_category"],v["_group"],v["_device"],v["_name"]]
            schedule_count_data = get(["scheduled_count", tag_id])
            scheduled_count = if (schedule_count_data), do: schedule_count_data, else: (set(["scheduled_count", tag_id], 0); 0)
            if (scheduled_count < 2) do
              scheduler_id = inspect System.os_time()
              set(["scheduler", scheduler_id], true)
              count(["scheduled_count", tag_id], 1)
              Log.info("melsec serial: function: read_tag: scheduler: " <> inspect(get(["scheduler"])))
              result = Enum.find_value(1..100000, false, fn x ->
                :timer.sleep(1)
                priority = get(["priority_scheduler"])
                priority_scheduler = if (priority), do: priority |> Map.keys(), else: []
                if (length(priority_scheduler) == 0) do
                  schedulers = get(["scheduler"]) |> Map.keys()
                  Enum.at(schedulers, 0) === scheduler_id
                else
                  false
                end
              end) |> if do
                {key, offset, data_type} = function("parse_tag_data", v["_condition"]["address"])
                Log.info("melsec serial: function: read_tag: key: " <> key <> ", " <> offset <> ", " <> data_type)
                frame = get("frame")
                format = get("format")
                data = encode(%{
                 "body" => %{
                   "device_code" => key,
                   "num_device_point" => v["_condition"]["length"] |> Integer.to_string(16) |> String.pad_leading(4, "0"),
                   "num_head_device" => offset
                 },
                  "header" => %{
                   "num_network" => get("num_network"),
                   "num_plc" => get("num_plc"),
                   "num_station" => get("num_station"),
                   "num_station_self" => get("num_station_self"),
                   "request_dest_module_num_station" => get("request_dest_module_num_station"),
                   "request_dest_num_IO" => get("request_dest_num_IO"),
                 }
                }, ("read_variable_" <> data_type <> "_" <> format <> "_" <> frame)).result
                Log.info("melsec serial: function: read_tag: beforesend: " <> inspect(data))
                instance("client", "send", data)
                result = Enum.find_value(1..2000, <<>>, fn x ->
                  :timer.sleep(1)
                  received = instance("client", "read received")
                  if (received == ""), do: false, else: received
                end) |> case do
                  <<>> ->
                    Log.warn("melsec serial: function: read_tag: timeout:")
                    ""
                  received ->
                    Log.info(received)
                    ret = received |> Map.get("block_data")
                    Log.info("melsec serial: function: read_tag: result: " <> inspect(ret))
                    parsed_ret = (unless is_list(ret) do
                      ret
                    else
                      ret
                      |> Enum.map( fn k -> k  |> Map.get("data")  end)
                      |> Enum.reduce(fn x, acc ->  acc <> x end)
                    end)
                    Log.info("melsec serial: function: read_tag: result2: " <> inspect(parsed_ret))
                    parsed_ret
                end
                clear(["scheduler", scheduler_id])
                count(["scheduled_count", tag_id], -1)
                {:ok, result}
              else
                clear(["scheduler", scheduler_id])
                count(["scheduled_count", tag_id], -1)
                Log.warn("melsec serial: function: read_tag: timeout: " <> inspect(v))
                {:error, "timeout"}
              end
            else
              {:error, "queue full for tag: " <> inspect(tag_id)}
            end
        testInput:
          default: |
            %{
            "_condition" => %{
             "address" => "D*100",
             "length" => 2
            },
            "_category" => "device",
            "device"=> "D1",
            "group" =>"G1",
             "name" => "tag"
            }
      write_tag:
        logic:
          $action: "elixir"
          value: |
            scheduler_id = inspect System.os_time()
            set(["priority_scheduler", scheduler_id], true)
            Log.info("melsec serial: function: write_tag: priority_scheduler: " <> inspect(get(["priority_scheduler"])))
            Log.info("melsec serial: function: write_tag: v: " <> inspect(v))
            result = Enum.find_value(1..100000, false, fn x ->
              :timer.sleep(1)
              schedulers = get(["priority_scheduler"]) |> Map.keys()
              Enum.at(schedulers, 0) === scheduler_id
            end) |> if do
              Log.info("melsec serial: function: enter ")
              frame = get("frame")
              format = get("format")
              {key, offset, data_type} = function("parse_tag_data", v["properties"]["_condition"]["address"])
              Log.info("melsec serial: function: write: " <> inspect(v))
              Log.info("key: "<>key <>", offset: " <> offset<> ", data_type: " <> data_type)
              write_count = v["properties"]["_condition"]["length"] |> Integer.to_string() |> String.pad_leading(4,"0000")
              Log.info("melsec serial: function: write_count: " <> inspect(write_count))
              write_data = (if data_type === "bit" do
                v["value"]
              else
                Integer.to_string(v["value"], 2)
                |> String.codepoints
                |> Enum.chunk(4)
                |> Enum.map(&Enum.join/1)
                |> Enum.map( fn x -> %{"data" => x}  end)
              end)
              Log.info("melsec serial: function: write_tag: write_data: " <> inspect(write_data))
              data = encode(%{
                "body" => %{
                  "block_device" => %{
                   "device_code" => key,
                   "num_device_point" => write_count,
                   "num_head_device" => offset
                  },
                 "block_data" => %{
                    "data" => write_data
                   }
                 },
                 "header" => %{
                   "num_network" => get("num_network"),
                   "num_plc" => get("num_plc"),
                   "num_station" => get("num_station"),
                   "num_station_self" => get("num_station_self"),
                   "request_dest_module_num_station" => get("request_dest_module_num_station"),
                   "request_dest_num_IO" => get("request_dest_num_IO"),
                 }
              }, "write_variable_"  <> data_type <> "_" <> format <> "_" <> frame ).result
              Log.info("melsec serial: function: write_tag: send: " <> inspect(data))
              instance("client", "send", data)
              result = Enum.find_value(1..3000, <<>>, fn x ->
                :timer.sleep(1)
                received = instance("client", "read received")
                if (received == ""), do: false, else: received
              end) |> case do
                <<>> -> Log.info("melsec serial: function: write_tag: timeout:")
                ret ->
                  Log.info("melsec serial: function: write_tag: result: " <> inspect(ret))
                  ret
              end
              clear(["priority_scheduler", scheduler_id])
              {:ok, result}
            else
              clear(["priority_scheduler", scheduler_id])
              Log.warn("melsec serial: function: write_tag: timeout: " <> inspect(v))
              {:error, "timeout"}
            end
        testInput:
          default: |
            %{
                "properties" => %{
                  "_condition" => %{
                    "address" => "M*",
                    "data_type" => "bit",
                    "offset" => 100,
                    "length" => 8
                  }
               },
              "value" => 255,
            "_category" => "device",
            "device"=> "D1",
            "group" =>"G1",
             "name" => "tag"
            }
    instance:
      client:
        data:
          data_bits:
            $action: "elixir"
            value: |
              get("data_bits")
          framing:
            $action: "elixir"
            value: |
              get("framing")
          framing_separator:
            $action: "elixir"
            value: |
              get("framing_separator")
          framing_timeout:
            $action: "elixir"
            value: |
              get("framing_timeout")
          parity:
            $action: "elixir"
            value: |
              get("parity")
          port:
            $action: "elixir"
            value: |
              get("port")
          speed:
            $action: "elixir"
            value: |
              get("speed")
          stop_bits:
            $action: "elixir"
            value: |
              get("stop_bits")
          models:
            $action: "elixir"
            value: |
              case get("format") do
                 "4F" ->
                  ["read_variable_word_4F_2C_ACK", "read_variable_word_4F_3C_ACK", "read_variable_word_4F_4C_ACK",
                  "read_variable_bit_4F_2C_ACK", "read_variable_bit_4F_3C_ACK", "read_variable_bit_4F_4C_ACK",
                  "write_4F_2C_ACK", "write_4F_3C_ACK", "write_4F_4C_ACK", "NAK_4F_2C", "NAK_4F_3C", "NAK_4F_4C"]
                 "2F" ->
                  ["read_variable_word_2F_2C_ACK", "read_variable_word_2F_3C_ACK", "read_variable_word_2F_4C_ACK",
                  "read_variable_bit_2F_2C_ACK", "read_variable_bit_2F_3C_ACK", "read_variable_bit_2F_4C_ACK",
                  "write_2F_2C_ACK", "write_2F_3C_ACK", "write_2F_4C_ACK", "NAK_2F_2C", "NAK_2F_3C", "NAK_2F_4C"]
                 "1F" ->
                  ["read_variable_word_1F_2C_ACK", "read_variable_word_1F_3C_ACK", "read_variable_word_1F_4C_ACK",
                  "read_variable_bit_1F_2C_ACK", "read_variable_bit_1F_3C_ACK", "read_variable_bit_1F_4C_ACK",
                  "write_1F_2C_ACK", "write_1F_3C_ACK", "write_1F_4C_ACK", "NAK_1F_2C", "NAK_1F_3C", "NAK_1F_4C"]
              end
        event:
          NAK_1F_2C:
            $action: "log"
            label: "NAK_1F_2C"
          NAK_1F_3C:
            $action: "log"
            label: "NAK_1F_3C"
          NAK_1F_4C:
            $action: "log"
            label: "NAK_1F_4C"
          NAK_2F_2C:
            $action: "log"
            label: "NAK_2F_2C"
          NAK_2F_3C:
            $action: "log"
            label: "NAK_2F_3C"
          NAK_2F_4C:
            $action: "log"
            label: "NAK_2F_4C"
          NAK_4F_2C:
            $action: "log"
            label: "NAK_4F_2C"
          NAK_4F_3C:
            $action: "log"
            label: "NAK_4F_3C"
          NAK_4F_4C:
            $action: "log"
            label: "NAK_4F_4C"
          read_variable_bit_1F_2C_ACK:
            $action: "log"
            label: "read_variable_bit_1F_2C_ACK"
          read_variable_bit_1F_3C_ACK:
            $action: "log"
            label: "read_variable_bit_1F_3C_ACK"
          read_variable_bit_1F_4C_ACK:
            $action: "log"
            label: "read_variable_bit_1F_4C_ACK"
          read_variable_bit_2F_2C_ACK:
            $action: "log"
            label: "read_variable_bit_2F_2C_ACK"
          read_variable_bit_2F_3C_ACK:
            $action: "log"
            label: "read_variable_bit_2F_3C_ACK"
          read_variable_bit_2F_4C_ACK:
            $action: "log"
            label: "read_variable_bit_2F_4C_ACK"
          read_variable_bit_4F_2C_ACK:
            $action: "log"
            label: "read_variable_bit_4F_2C_ACK"
          read_variable_bit_4F_3C_ACK:
            $action: "log"
            label: "read_variable_bit_4F_3C_ACK"
          read_variable_bit_4F_4C_ACK:
            $action: "log"
            label: "read_variable_bit_4F_4C_ACK"
          read_variable_word_1F_2C_ACK:
            $action: "log"
            label: "read_variable_word_1F_2C_ACK"
          read_variable_word_1F_3C_ACK:
            $action: "log"
            label: "read_variable_word_1F_3C_ACK"
          read_variable_word_1F_4C_ACK:
            $action: "log"
            label: "read_variable_word_1F_4C_ACK"
          read_variable_word_2F_2C_ACK:
            $action: "log"
            label: "read_variable_word_2F_2C_ACK"
          read_variable_word_2F_3C_ACK:
            $action: "log"
            label: "read_variable_word_2F_3C_ACK"
          read_variable_word_2F_4C_ACK:
            $action: "log"
            label: "read_variable_word_2F_4C_ACK"
          read_variable_word_4F_2C_ACK:
            $action: "log"
            label: "read_variable_word_4F_2C_ACK"
          read_variable_word_4F_3C_ACK:
            $action: "log"
            label: "read_variable_word_4F_3C_ACK"
          read_variable_word_4F_4C_ACK:
            $action: "log"
            label: "read_variable_word_4F_4C_ACK"
          received:
            none:
              $action: "elixir"
              value: |
                Log.info("inspect #{v}")
          write_1F_2C_ACK:
            $action: "log"
            label: "write_1F_2C_ACK"
          write_1F_3C_ACK:
            $action: "log"
            label: "write_1F_3C_ACK"
          write_1F_4C_ACK:
            $action: "log"
            label: "write_1F_4C_ACK"
          write_2F_2C_ACK:
            $action: "log"
            label: "write_2F_2C_ACK"
          write_2F_3C_ACK:
            $action: "log"
            label: "write_2F_3C_ACK"
          write_2F_4C_ACK:
            $action: "log"
            label: "write_2F_4C_ACK"
          write_4F_2C_ACK:
            $action: "log"
            label: "write_4F_2C_ACK"
          write_4F_3C_ACK:
            $action: "log"
            label: "write_4F_3C_ACK"
          write_4F_4C_ACK:
            $action: "log"
            label: "write_4F_4C_ACK"
        use: "serial"
    model:
      NAK_1F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "NAK"
            size: 1
            type: "integer"
            value: 21
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "FB"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_2C"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "7151"
            name: "error_code"
            size: 4
            type: "bytes"
      NAK_1F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "NAK"
            size: 1
            type: "integer"
            value: 21
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F9"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_3C"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "7151"
            name: "error_code"
            size: 4
            type: "bytes"
      NAK_1F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "NAK"
            size: 1
            type: "integer"
            value: 21
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F8"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_4C"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "7151"
            name: "error_code"
            size: 4
            type: "bytes"
      NAK_2F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "NAK"
            size: 1
            type: "integer"
            value: 21
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_block"
            size: 2
            type: "bytes"
            value: "00"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "FB"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_2C"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "7151"
            name: "error_code"
            size: 4
            type: "bytes"
      NAK_2F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "NAK"
            size: 1
            type: "integer"
            value: 21
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_block"
            size: 2
            type: "bytes"
            value: "00"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F9"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_3C"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "7151"
            name: "error_code"
            size: 4
            type: "bytes"
      NAK_2F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "NAK"
            size: 1
            type: "integer"
            value: 21
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_block"
            size: 2
            type: "bytes"
            value: "00"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F8"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_4C"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "7151"
            name: "error_code"
            size: 4
            type: "bytes"
      NAK_4F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "NAK"
            size: 1
            type: "integer"
            value: 21
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "FB"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_2C"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "7151"
            name: "error_code"
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
      NAK_4F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "NAK"
            size: 1
            type: "integer"
            value: 21
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F9"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_3C"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "7151"
            name: "error_code"
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
      NAK_4F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "NAK"
            size: 1
            type: "integer"
            value: 21
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F8"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_4C"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "7151"
            name: "error_code"
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
      block_4F_end:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "CR"
            size: 1
            type: "integer"
            value: 13
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "LF"
            size: 1
            type: "integer"
            value: 10
      block_body_write:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "block_device"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_data"
            name: "block_data"
            overrides:
              data:
                size:
                  $action: "elixir"
                  value: |
                    String.to_integer(v["block_device"]["num_device_point"], 16)
        parser: "binary"
      block_checksum:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "checksum"
            size: 2
            type: "bytes"
            value:
              $action: "elixir"
              value: |
                value_encoding = v[:__fields__]
                value = (if value_encoding === nil, do: v["__state__"] |> Map.get(:result), else: value_encoding)
                value_tmp = if value_encoding === nil do
                    if value["block_data"] !== nil do
                      block_data = value["block_data"]
                      block_data_parsed = if is_list(block_data) do
                          block_data |> Enum.map(fn x -> Map.values(x) end) |> List.flatten |> List.to_string
                        else
                          block_data
                        end
                      tmp = Map.replace!(value, "block_data", block_data_parsed)
                      Map.merge(tmp, tmp["header"]) |> Map.delete("header")
                    else
                      value
                    end
                  else
                    if Enum.member?([<<2 >>, <<5>>], binary_part(value["header"], 0, 1)), do: Map.replace!(value, "header", binary_part(value["header"], 1, (value["header"] |> byte_size) -1)), else: value
                  end
                value_tmp |> Map.drop(["ENQ", "STX", "ACK"]) |> Map.values() |> List.to_string() |> :binary.bin_to_list() |> Enum.sum() |> Integer.to_string(16) |> String.slice(-2, 2)
      block_command_3C4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "command"
            size: 4
            type: "bytes"
            value: "0000"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "sub_command"
            size: 4
            type: "bytes"
            value: "0000"
      block_data:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "0000"
            name: "data"
            size: 4
            type: "bytes"
      block_device:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            deafult: "M*"
            name: "device_code"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "000000"
            name: "num_head_device"
            size: 6
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_device_point"
            size: 4
            type: "bytes"
      block_header_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "num_station"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "num_station_self"
            size: 2
            type: "bytes"
      block_header_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "num_station"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "num_network"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "FF"
            name: "num_plc"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "num_station_self"
            size: 2
            type: "bytes"
      block_header_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "num_station"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "num_network"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "FF"
            name: "num_plc"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "03FF"
            name: "request_dest_num_IO"
            size: 4
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "request_dest_module_num_station"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "00"
            name: "num_station_self"
            size: 2
            type: "bytes"
        testInput:
          decode: "\"F90000FF00\""
          encode: |
            %{
            }
      block_request_header_1F4F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ENQ"
            size: 1
            type: "integer"
            value: 5
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "FB"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_2C"
      block_request_header_1F4F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ENQ"
            size: 1
            type: "integer"
            value: 5
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F9"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_3C"
      block_request_header_1F4F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ENQ"
            size: 1
            type: "integer"
            value: 5
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F8"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_4C"
      block_request_header_2F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ENQ"
            size: 1
            type: "integer"
            value: 5
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_block"
            size: 2
            type: "bytes"
            value: "00"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "FB"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_2C"
      block_request_header_2F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ENQ"
            size: 1
            type: "integer"
            value: 5
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_block"
            size: 2
            type: "bytes"
            value: "00"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F9"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_3C"
      block_request_header_2F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ENQ"
            size: 1
            type: "integer"
            value: 5
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_block"
            size: 2
            type: "bytes"
            value: "00"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F8"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_4C"
      block_response_header_1F4F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "STX"
            size: 1
            type: "integer"
            value: 2
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "FB"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_2C"
      block_response_header_1F4F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "STX"
            size: 1
            type: "integer"
            value: 2
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F9"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_3C"
      block_response_header_1F4F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "STX"
            size: 1
            type: "integer"
            value: 2
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F8"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_4C"
      block_response_header_2F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "STX"
            size: 1
            type: "integer"
            value: 2
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_block"
            size: 2
            type: "bytes"
            value: "00"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "FB"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_2C"
      block_response_header_2F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "STX"
            size: 1
            type: "integer"
            value: 2
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_block"
            size: 2
            type: "bytes"
            value: "00"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F9"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_3C"
      block_response_header_2F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "STX"
            size: 1
            type: "integer"
            value: 2
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_block"
            size: 2
            type: "bytes"
            value: "00"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F8"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_4C"
      read_variable_bit_1F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "1"
            name: "command"
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_bit_1F_2C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_1F4F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01101"
            name: "block_data"
            size:
              $action: "elixir"
              value: |
                (v["__state__"] |> Map.get(:data) |> byte_size) - 3
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_bit_1F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "0401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_bit_1F_3C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_1F4F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01101"
            name: "block_data"
            size:
              $action: "elixir"
              value: |
                (v["__state__"] |> Map.get(:data) |> byte_size) - 3
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_bit_1F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "0401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_bit_1F_4C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_1F4F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01101"
            name: "block_data"
            size:
              $action: "elixir"
              value: |
                (v["__state__"] |> Map.get(:data) |> byte_size) - 3
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_bit_2F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_2F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "1"
            name: "command"
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_bit_2F_2C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_2F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01101"
            name: "block_data"
            size:
              $action: "elixir"
              value: |
                (v["__state__"] |> Map.get(:data) |> byte_size) - 3
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_bit_2F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_2F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "0401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_bit_2F_3C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_2F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01101"
            name: "block_data"
            size:
              $action: "elixir"
              value: |
                (v["__state__"] |> Map.get(:data) |> byte_size) - 3
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_bit_2F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_2F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "0401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_bit_2F_4C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_2F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01101"
            name: "block_data"
            size:
              $action: "elixir"
              value: |
                (v["__state__"] |> Map.get(:data) |> byte_size) - 3
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_bit_4F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "1"
            name: "command"
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      read_variable_bit_4F_2C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_1F4F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01101"
            name: "block_data"
            size:
              $action: "elixir"
              value: |
                (v["__state__"] |> Map.get(:data) |> byte_size) - 5
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
        parser: "binary"
      read_variable_bit_4F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "0401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      read_variable_bit_4F_3C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_1F4F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01101"
            name: "block_data"
            size:
              $action: "elixir"
              value: |
                (v["__state__"] |> Map.get(:data) |> byte_size) - 5
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
        parser: "binary"
      read_variable_bit_4F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "0401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      read_variable_bit_4F_4C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_1F4F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "01101"
            name: "block_data"
            size:
              $action: "elixir"
              value: |
                (v["__state__"] |> Map.get(:data) |> byte_size) - 5
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
        parser: "binary"
      read_variable_word_1F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "2"
            name: "command"
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_word_1F_2C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_1F4F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                ((v["__state__"] |> Map.get(:data) |> byte_size) - 3)/4 |> trunc
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_word_1F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "0401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_word_1F_3C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_1F4F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                ((v["__state__"] |> Map.get(:data) |> byte_size) - 3)/4 |> trunc
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_word_1F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "0401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_word_1F_4C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_1F4F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                ((v["__state__"] |> Map.get(:data) |> byte_size) - 3)/4 |> trunc
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_word_2F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_2F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "2"
            name: "command"
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_word_2F_2C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_2F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                ((v["__state__"] |> Map.get(:data) |> byte_size) - 3)/4 |> trunc
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_word_2F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_2F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "0401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_word_2F_3C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_2F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                ((v["__state__"] |> Map.get(:data) |> byte_size) - 3)/4 |> trunc
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_word_2F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_2F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "0401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_word_2F_4C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_2F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                ((v["__state__"] |> Map.get(:data) |> byte_size) - 3)/4 |> trunc
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      read_variable_word_4F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "2"
            name: "command"
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      read_variable_word_4F_2C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_1F4F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                ((v["__state__"] |> Map.get(:data) |> byte_size) - 5)/4 |> trunc
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      read_variable_word_4F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "0401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
        parser: "binary"
      read_variable_word_4F_3C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_1F4F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                ((v["__state__"] |> Map.get(:data) |> byte_size) - 5)/4 |> trunc
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      read_variable_word_4F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "0401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
        parser: "binary"
      read_variable_word_4F_4C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_response_header_1F4F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                ((v["__state__"] |> Map.get(:data) |> byte_size) - 5)/4 |> trunc
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ETX"
            size: 1
            type: "integer"
            value: 3
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      write_1F_2C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ACK"
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "FB"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_2C"
            name: "header"
      write_1F_3C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ACK"
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F9"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_3C"
            name: "header"
      write_1F_4C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ACK"
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F8"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_4C"
            name: "header"
      write_2F_2C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ACK"
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_block"
            size: 2
            type: "bytes"
            value: "00"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "FB"
            name: "num_frame_id"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_2C"
            name: "header"
      write_2F_3C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ACK"
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_block"
            size: 2
            type: "bytes"
            value: "00"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "F9"
            name: "num_frame_id"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_3C"
            name: "header"
      write_2F_4C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ACK"
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_block"
            size: 2
            type: "bytes"
            value: "00"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "F8"
            name: "num_frame_id"
            size: 2
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_4C"
            name: "header"
      write_4F_2C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ACK"
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "FB"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      write_4F_3C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ACK"
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F9"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      write_4F_4C_ACK:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "ACK"
            size: 1
            type: "integer"
            value: 6
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            name: "num_frame_id"
            size: 2
            type: "bytes"
            value: "F8"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_header_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      write_variable_bit_1F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "3"
            name: "command"
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_body_write"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      write_variable_bit_1F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "1401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_body_write"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      write_variable_bit_1F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "1401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_body_write"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      write_variable_bit_2F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_2F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "3"
            name: "command"
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_body_write"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      write_variable_bit_2F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_2F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "1401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_body_write"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      write_variable_bit_2F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_2F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "1401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_body_write"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      write_variable_bit_4F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "3"
            name: "command"
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_body_write"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      write_variable_bit_4F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "1401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_body_write"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      write_variable_bit_4F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "1401"
              sub_command:
                value: "0001"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_body_write"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      write_variable_word_1F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "4"
            name: "command"
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["body"]["num_device_point"] |> String.to_integer(16)
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      write_variable_word_1F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "1401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["body"]["num_device_point"] |> String.to_integer(16)
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      write_variable_word_1F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "1401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["body"]["num_device_point"] |> String.to_integer(16)
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      write_variable_word_2F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_2F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "4"
            name: "command"
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["body"]["num_device_point"] |> String.to_integer(16)
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      write_variable_word_2F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_2F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "1401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["body"]["num_device_point"] |> String.to_integer(16)
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      write_variable_word_2F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_2F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "1401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["body"]["num_device_point"] |> String.to_integer(16)
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
      write_variable_word_4F_2C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_2C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Field"
            default: "4"
            name: "command"
            size: 1
            type: "bytes"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["body"]["num_device_point"] |> String.to_integer(16)
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      write_variable_word_4F_3C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_3C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "1401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["body"]["num_device_point"] |> String.to_integer(16)
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
      write_variable_word_4F_4C:
        $parser: "binary"
        fields:
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_request_header_1F4F_4C"
            name: "header"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_command_3C4C"
            name: "command"
            overrides:
              command:
                value: "1401"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_device"
            name: "body"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            count:
              $action: "elixir"
              value: |
                v["body"]["num_device_point"] |> String.to_integer(16)
            model: "block_data"
            name: "block_data"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_checksum"
          - __struct__: "Elixir.Compiler.Model.Binary.Struct.Reference"
            model: "block_4F_end"
            name: "end"
