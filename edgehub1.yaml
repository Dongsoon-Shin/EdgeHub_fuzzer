data:
  admin:
    default:
      license:
        id: ""
        key: ""
      support:
        email: "support@interactor.com"
        phone: "+1 408 484 7780"
      system:
        name: "EdgeHub"
  base_dir:
    default: "/Users/ilgwonpark/Documents/GitHub/LSIS-EdgeHub/ui/dist"
    persistent: true
  config:
    persistent: true
  defaultConfig:
    default:
      actions: []
      clients: []
      devices:
        - name: "Virtual"
          properties:
            category: "virtual"
      groups:
        - name: "_"
          properties:
            comment: ""
      mappings: []
      protocols:
        cnet:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - default: ""
              key: "port"
              name: "Port"
              type: "input"
              valueType: "text"
            - default: 255
              key: "uid"
              name: "Unique ID"
              type: "input"
              valueType: "number"
            - default: 115200
              key: "speed"
              name: "Baudrate"
              type: "input"
              valueType: "number"
            - default: 8
              key: "data_bits"
              name: "Data Bits"
              type: "input"
              valueType: "number"
            - default: "none"
              key: "parity"
              name: "Parity"
              type: "input"
              valueType: "text"
            - default: 1
              key: "stop_bits"
              name: "Stop Bits"
              type: "input"
              valueType: "number"
          serial: true
          tagInfo:
            - key: "address"
              name: "Start address"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - key: "length"
              name: "Length"
              type: "input"
              valueType: "number"
          text: "CNET"
        fenet:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - default: "127.0.0.1"
              key: "address"
              name: "Address"
              type: "input"
              valueType: "text"
            - default: 2004
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
            - default: 0
              key: "slot"
              name: "Slot"
              type: "input"
              valueType: "number"
            - default: 0
              key: "base"
              name: "Base"
              type: "input"
              valueType: "number"
            - default: "LSIS-XGT"
              key: "company_id"
              name: "Company ID"
              options:
                - key: "LSIS-XGT"
                  text: "LSIS-XGT"
                - key: "LSIS-GLOFA"
                  text: "LSIS-GLOFA"
              type: "select"
            - default: "XGI"
              key: "cpu_info"
              name: "CPU Info"
              options:
                - key: "XGK"
                  text: "XGK"
                - key: "XGI"
                  text: "XGI"
                - key: "XGR"
                  text: "XGR"
              type: "select"
          tagInfo:
            - key: "address"
              name: "Start address"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - key: "length"
              name: "Length"
              type: "input"
              valueType: "number"
          text: "FENET"
        http server:
          builtIn: true
          category: "server"
          config: {}
          connectionInfo:
            - default: 2290
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
          text: "HTTP"
        mariadb:
          builtIn: true
          category: "database"
          config: {}
          connectionInfo:
            - default: "127.0.0.1"
              key: "address"
              name: "Address"
              type: "input"
              valueType: "text"
            - default: 3306
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
            - default: "EdgeHub"
              key: "database"
              name: "Database"
              type: "input"
              valueType: "text"
            - default: "root"
              key: "username"
              name: "Username"
              type: "input"
              valueType: "text"
            - default: ""
              key: "password"
              name: "Password"
              type: "input"
              valueType: "text"
            - default: ""
              key: "type"
              name: "Type"
              options:
                - key: "edgehub"
                  text: "EdgeHub"
                - key: "custom"
                  text: "Custom"
              type: "select"
              valueType: "text"
          tagInfo:
            - key: "table"
              name: "Table"
              type: "input"
              valueType: "text"
            - key: "column"
              name: "Colunm"
              type: "input"
              valueType: "text"
            - key: "condition"
              name: "Condition"
              type: "input"
              valueType: "text"
          text: "MariaDB EdgeHub"
        mariadb custom:
          builtIn: true
          category: "database"
          config: {}
          connectionInfo:
            - default: "127.0.0.1"
              key: "address"
              name: "Address"
              type: "input"
              valueType: "text"
            - default: 3306
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
            - default: "EdgeHub"
              key: "database"
              name: "Database"
              type: "input"
              valueType: "text"
              namingRule: "id"
            - default: "root"
              key: "username"
              name: "Username"
              type: "input"
              valueType: "text"
              namingRule: "id"
            - default: ""
              key: "password"
              name: "Password"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - default: ""
              key: "type"
              name: "Type"
              options:
                - key: "edgehub"
                  text: "EdgeHub"
                - key: "custom"
                  text: "Custom"
              type: "select"
              valueType: "text"
          tagInfo:
            - key: "table"
              name: "Table"
              type: "input"
              valueType: "text"
            - key: "column"
              name: "Colunm"
              type: "input"
              valueType: "text"
            - key: "condition"
              name: "Condition"
              type: "input"
              valueType: "text"
          text: "MariaDB Custom"
        modbus rtu master:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - default: ""
              key: "port"
              name: "Port"
              type: "input"
              valueType: "text"
            - default: 255
              key: "uid"
              name: "Unique ID"
              type: "input"
              valueType: "number"
            - default: 115200
              key: "speed"
              name: "Baudrate"
              type: "input"
              valueType: "number"
            - default: 8
              key: "data_bits"
              name: "Data Bits"
              type: "input"
              valueType: "number"
            - default: "none"
              key: "parity"
              name: "Parity"
              type: "input"
              valueType: "text"
            - default: 1
              key: "stop_bits"
              name: "Stop Bits"
              type: "input"
              valueType: "number"
          serial: true
          tagInfo:
            - key: "address"
              name: "Start address"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - key: "length"
              name: "Length"
              type: "input"
              valueType: "number"
          text: "Modbus RTU"
        modbus tcp master:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - default: "127.0.0.1"
              key: "address"
              name: "Address"
              type: "input"
              valueType: "text"
            - default: 502
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
            - default: 255
              key: "uid"
              name: "Unique ID"
              type: "input"
              valueType: "number"
          tagInfo:
            - key: "address"
              name: "Start address"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - key: "length"
              name: "Length"
              type: "input"
              valueType: "number"
          text: "Modbus TCP"
        modbus tcp slave:
          builtIn: true
          category: "server"
          config: {}
          connectionInfo:
            - default: 502
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
            - default: "1"
              key: "uids"
              name: "UIDs"
              type: "input"
              valueType: "text"
          tagIdFields:
            - default: 1
              key: "id"
              name: "ID"
              type: "input"
              valueType: "number"
            - default: "register"
              key: "type"
              name: "Type"
              options:
                - key: "coil"
                  text: "Coil (0x)"
                - key: "discrete"
                  text: "Discrete Input (1x)"
                - key: "input"
                  text: "Input Register (3x)"
                - key: "holding"
                  text: "Holding Register (4x)"
              type: "select"
              valueType: "text"
            - default: 0
              key: "address"
              name: "Address"
              type: "input"
              valueType: "number"
          tagInfo:
            - key: "category"
              name: "Category"
              type: "categories"
              valueType: "text"
            - key: "group"
              name: "Group"
              type: "groups"
              valueType: "text"
            - key: "device"
              name: "Device"
              type: "devices"
              valueType: "text"
            - key: "tag"
              name: "Tag"
              type: "tags"
              valueType: "text"
          text: "Modbus TCP"
        opcua client:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - key: "address"
              name: "Address"
              type: "input"
              valueType: "text"
            - key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
          tagInfo:
            - key: "id"
              name: "Object ID"
              type: "input"
              valueType: "text"
          text: "OPC UA"
        opcua server:
          builtIn: true
          category: "server"
          config: {}
          connectionInfo:
            - key: "port"
              default: 53530
              name: "Port"
              type: "input"
              valueType: "number"
          tagInfo: []
          text: "OPC UA"
        melsec ethernet:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - default: "127.0.0.1"
              key: "address"
              name: "Address"
              type: "input"
              valueType: "text"
            - default: 5002
              key: "port"
              name: "Port"
              type: "input"
              valueType: "number"
            - default: "00"
              key: "network_number"
              name: "Network Number"
              type: "input"
              valueType: "text"
            - default: "00"
              key: "station_number"
              name: "Station Number"
              type: "input"
              valueType: "text"
            - default: "FF"
              key: "plc_number"
              name: "PLC Number"
              type: "input"
              valueType: "text"
            - default: "03FF"
              key: "io_number"
              name: "IO Number"
              type: "input"
              valueType: "text"
            - default: "binary"
              key: "communication_type"
              name: "Communication Type"
              options:
                - key: "binary"
                  text: "Binary"
                - key: "ASCII"
                  text: "ASCII"
              type: "select"
          tagInfo:
            - key: "address"
              name: "Start address"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - key: "length"
              name: "Length"
              type: "input"
              valueType: "number"
          text: "MELSEC ETHERNET"
        melsec serial:
          builtIn: true
          category: "device"
          config: {}
          connectionInfo:
            - default: ""
              key: "port"
              name: "Port"
              type: "input"
              valueType: "text"
            - default: 9600
              key: "speed"
              name: "Baudrate"
              type: "input"
              valueType: "number"
            - default: 8
              key: "data_bits"
              name: "Data Bits"
              type: "input"
              valueType: "number"
            - default: "none"
              key: "parity"
              name: "Parity"
              type: "input"
              valueType: "text"
            - default: 1
              key: "stop_bits"
              name: "Stop Bits"
              type: "input"
              valueType: "number"
            - default: "4F"
              key: "format"
              name: "Format"
              options:
                - key: "1F"
                  text: "1F"
                - key: "2F"
                  text: "2F"
                - key: "4F"
                  text: "4F"
              type: "select"
            - default: "4C"
              key: "frame"
              name: "Frame"
              options:
                - key: "2C"
                  text: "2C"
                - key: "3C"
                  text: "3C"
                - key: "4C"
                  text: "4C"
              type: "select"
            - default: "00"
              key: "num_station"
              name: "Station Number"
              type: "input"
              valueType: "text"
            - default: "FF"
              key: "num_station_self"
              name: "Self Station Number"
              type: "input"
              valueType: "text"
            - default: "00"
              key: "num_network"
              name: "Network number"
              type: "input"
              valueType: "text"
              condition:
                field: "frame"
                action: "includes"
                value:
                  - "3C"
                  - "4C"
            - default: "FF"
              key: "num_plc"
              name: "PLC number"
              type: "input"
              valueType: "text"
              condition:
                field: "frame"
                action: "includes"
                value:
                  - "3C"
                  - "4C"
            - default: "00"
              key: "request_dest_module_num_station"
              name: "Request Destination Module Station Number"
              type: "input"
              valueType: "text"
              condition:
                field: "frame"
                action: "includes"
                value:
                  - "4C"
            - default: "03FF"
              key: "request_dest_num_IO"
              name: "Request Destination I/O Number"
              type: "input"
              valueType: "text"
              condition:
                field: "frame"
                action: "includes"
                value:
                  - "3C"
                  - "4C"
          serial: true
          tagInfo:
            - key: "address"
              name: "Start address"
              type: "input"
              valueType: "text"
              namingRule: "A"
            - key: "length"
              name: "Length"
              type: "input"
              valueType: "number"
          text: "MELSEC SERIAL"
      tags: []
    persistent: true
  function:
    default: |
      db_put:
        logic:
          $action: "elixir"
          value: |
            Log.info("db_put: v: #{inspect v}")
            category = v["tag"]["properties"]["_category"] || ""
            group = v["tag"]["properties"]["_group"] || ""
            device = v["tag"]["properties"]["_device"] || ""
            tag_name = v["tag"]["name"] || ""
            load_condition = v["tag"]["properties"]["_condition"]["_load_condition"] || ""
            body_string = cond do
              String.valid?(v["value"]) -> v["value"]
              is_binary(v["value"]) -> v["value"] |> Base.encode16()
              true -> inspect(v["value"])
            end
            tag_id = get(["tag_id", category, group, device, tag_name])
            query_value = "UPDATE tag SET tag_value = '#{body_string}' WHERE tag_id=#{tag_id};"
            edgehub_db_list = get("edgehub_db_list") || []
            edgehub_db_list |> Enum.each(fn db_name ->
              value_ret = instance(db_name, "query", query_value)
              if v["tag"]["properties"]["_condition"]["_history"] == "enable" do
                if ((load_condition == "") || function("parse_and_eval", %{"logic" => body_string <> " " <> load_condition, "allow_char" => false})) do
                  query_history = "INSERT INTO tag_history (tag_id, value) VALUES (#{tag_id}, '#{body_string}')"
                  history_ret = instance(db_name, "query", query_history)
                end
              end
            end)
      execute_actions:
        logic:
          $action: "elixir"
          value: |
            Log.info("execute_actions: v: #{inspect v}")
            category = v["tag"]["properties"]["_category"] || ""
            group = v["tag"]["properties"]["_group"] || ""
            device = v["tag"]["properties"]["_device"] || ""
            tag_name = v["tag"]["name"] || ""
            actions = get("actions") || []
            action_results = actions |> Enum.filter(fn action ->
              action_category = action["properties"]["_category"] || ""
              action_group = action["properties"]["_group"] || ""
              action_device = action["properties"]["_device"] || ""
              {action_category, action_group, action_device, Enum.at(action["idFields"], 0)} == {category, group, device, tag_name}
            end) |> Enum.each(fn filtered_action ->
              action_condition = Enum.at(filtered_action["idFields"], 1) || ""
              value = cond do
                is_binary(v["value"]) -> inspect v["value"]
                true -> inspect v["value"]
              end
              if (action_condition == "" || function("parse_and_eval", %{"logic" => value <> " " <> action_condition, "allow_char" => true})) do
                value_tmp = function("parse_and_eval", %{"logic" => filtered_action["properties"]["value"], "allow_char" => true})
                key = category <> "_" <> group <> "_" <> tag_name
                tags = get("tags") || []
                case Enum.at(filtered_action["idFields"], 2) do
                  "tag" ->
                    case filtered_action["properties"]["category"] do
                      "device" ->
                        tags |> Enum.find(fn tag ->
                          (tag["properties"]["_group"] == filtered_action["properties"]["group"]) && (tag["properties"]["_device"] == filtered_action["properties"]["device"]) && (tag["name"] == filtered_action["properties"]["tag"])
                        end)
                      "database" ->
                        tags |> Enum.find(fn tag ->
                          (tag["properties"]["_category"] == "database") && (tag["properties"]["_device"] == filtered_action["properties"]["device"]) && (tag["name"] == filtered_action["properties"]["tag"])
                        end)
                      "virtual" ->
                        tags |> Enum.find(fn tag ->
                          (tag["properties"]["_category"] == "virtual") && (tag["properties"]["_device"] == filtered_action["properties"]["device"]) && (tag["name"] == filtered_action["properties"]["tag"])
                        end)
                      _ -> ""
                    end
                  "log" ->
                    Log.info("EdgeHub: Action: Execute: " <> key <> ": value: " <> inspect(value_tmp))
                    ""
                  _ ->
                    Log.error("EdgeHub: Action: Error: id:" <> Enum.at(filtered_action["idFields"], 2) <> " key:" <> key <> " value: " <> inspect(value_tmp))
                    ""
                end |> case do
                  "" -> :ok
                  target ->
                    target_properties = target["properties"]
                    valueType = target_properties["_condition"]["valueType"]
                    {typed_value, typed_binary} = function("transform", %{
                      "value" => value_tmp,
                      "type" => valueType,
                      "path" => [
                        "action",
                        filtered_action["properties"]["_category"],
                        filtered_action["properties"]["_group"] || "",
                        filtered_action["properties"]["_device"],
                        filtered_action["name"]
                      ]
                    })
                    case target_properties["_category"] do
                      "virtual" ->
                        Log.info("execute_actions: virtual: #{inspect target_properties}")
                        function("save_tag_value", %{
                          "value" => value_tmp,
                          "valueType" => valueType,
                          "typed_value" => typed_value,
                          "typed_binary" => typed_binary,
                          "path" => [
                            "tag",
                            filtered_action["properties"]["category"],
                            filtered_action["properties"]["group"] || "",
                            filtered_action["properties"]["device"],
                            filtered_action["properties"]["tag"]
                          ]
                        })
                      _ ->
                        instance_name = if (target_properties["communication"]["serial"]) do
                          "Serial_Port_" <> target_properties["communication"]["data"]["port"]
                        else
                          "#{filtered_action["properties"]["group"]}/#{filtered_action["properties"]["device"]}"
                        end
                        new_condition = function("parse_condition", target_properties["_condition"])
                        instance(instance_name, "write_tag", %{"properties" => target_properties |> Map.put("_condition", new_condition), "value" => typed_value})
                    end
                end
              end
            end)
      hex_2_binary:
        logic:
          $action: "elixir"
          value: |
            require Integer
            if (String.contains?(v, ".")) do
              nil
            else
              clean_hex = v |> String.replace("0x", "") |> String.replace(~r/[^0-9a-fA-F]/, "")
              hex = case (clean_hex |> String.length() |> Integer.is_even()) do
                true -> clean_hex
                false -> <<48>> <> clean_hex
              end
              case (hex |> Base.decode16(case: :mixed)) do
                {:ok, typed_value} ->
                  case typed_value do
                    "" -> nil
                    _ -> typed_value
                  end
                :error -> nil
              end
            end
      int_size:
        logic:
          $action: "elixir"
          value: |
            ((((:math.log2(abs(v))/8) |> :math.floor()) + 1) * 8) |> trunc()
      save_tag_value:
        logic:
          $action: "elixir"
          value: |
            value = v["value"]
            valueType = v["valueType"]
            typed_value = v["typed_value"]
            typed_binary = v["typed_binary"]
            path = v["path"]
            binary_string = if (typed_binary), do: "0x" <> (typed_binary |> Base.encode16()), else: "N/A"
            value_string = if (typed_value) do
              case valueType do
                "int" -> typed_value |> inspect()
                "uint" -> typed_value |> inspect()
                "float" -> typed_value |> inspect()
                "binary" -> "0x" <> (typed_value |> Base.encode16())
                "string-hex" -> "0x" <> (typed_value |> Base.encode16())
                "string-int" -> typed_value |> inspect()
                "string-uint" -> typed_value |> inspect()
                "string-float" -> typed_value |> inspect()
                "string-ascii" -> typed_value |> inspect()
                "hex-int" -> typed_value |> inspect()
                "hex-uint" -> typed_value |> inspect()
                "hex-float" -> typed_value |> inspect()
                _ ->
                  "N/A"
              end
            else
              "N/A"
            end
            raw_string = if (is_binary(value)), do: "0x" <> (value |> Base.encode16()), else: inspect value
            set(["raw_string"] ++ path, raw_string)
            set(["raw"] ++ path, value)
            set(["value"] ++ path, typed_value)
            set(["value_string"] ++ path, value_string)
            set(["binary"] ++ path, typed_binary)
            set(["binary_string"] ++ path, binary_string)
      transform:
        logic:
          $action: "elixir"
          value: |
            Log.info("function: transform: #{inspect v}")
            value = v["value"]
            valueType = v["type"]
            path = v["path"]
            {typed_value, typed_binary} = cond do
              is_float(value) ->
                case valueType do
                  "int" ->
                    typed_value = value |> trunc()
                    size = function("int_size", typed_value)
                    {typed_value, <<typed_value::signed-integer-size(size)>>}
                  "uint" ->
                    if (value < 0) do
                      {nil, nil}
                    else
                      typed_value = value |> trunc()
                      size = function("int_size", typed_value)
                      {typed_value, <<typed_value::unsigned-integer-size(size)>>}
                    end
                  "float" ->
                    {value, <<value::float>>}
                  "binary" ->
                    {<<value::float>>, <<value::float>>}
                  _ ->
                    {nil, nil}
                end
              is_integer(value) ->
                case valueType do
                  "int" ->
                    size = function("int_size", value)
                    {value, <<value::signed-integer-size(size)>>}
                  "uint" ->
                    if (value < 0) do
                      {nil, nil}
                    else
                      size = function("int_size", value)
                      {value, <<value::unsigned-integer-size(size)>>}
                    end
                  "float" ->
                    typed_value = value / 1
                    {typed_value, <<value::float>>}
                  "binary" ->
                    size = function("int_size", value)
                    {<<value::signed-integer-size(size)>>, <<value::signed-integer-size(size)>>}
                  _ ->
                    {nil, nil}
                end
              is_map(value) -> # Database value
                rows = value |> Map.get(:rows)
                case rows do
                  [[db_value]] -> db_value
                  [db_value] -> db_value
                  _ -> rows
                end
              is_binary(value) ->
                case valueType do
                  "int" ->
                    size = bit_size(value)
                    <<typed_value::signed-size(size)>> = value
                    {typed_value, value}
                  "uint" ->
                    size = bit_size(value)
                    <<typed_value::unsigned-size(size)>> = value
                    {typed_value, value}
                  "float" ->
                    case byte_size(value) do
                      4 ->
                        <<typed_value::float-size(32)>> = value
                        {typed_value, value}
                      8 ->
                        <<typed_value::float-size(64)>> = value
                        {typed_value, value}
                      _ ->
                        size = bit_size(value)
                        <<signed_value::signed-size(size)>> = value
                        <<unsigned_value::unsigned-size(size)>> = value
                        if (signed_value == unsigned_value) do
                          {signed_value/1, <<signed_value::float>>}
                        else
                          {nil, nil}
                        end
                    end
                  "binary" ->
                    {value, value}
                  "string-hex" ->
                    typed_value = function("hex_2_binary", value)
                    if (typed_value), do: {typed_value, typed_value}, else: {nil, nil}
                  "string-int" ->
                    case (value |> String.trim() |> Integer.parse()) do
                      {typed_value, _} ->
                        size = function("int_size", typed_value)
                        {typed_value, <<typed_value::signed-integer-size(size)>>}
                      :error -> {nil, nil}
                    end
                  "string-uint" ->
                    case (value |> String.trim() |> Integer.parse()) do
                      {val, _} ->
                        if (val < 0) do
                          {nil, nil}
                        else
                          typed_value = val |> abs()
                          size = function("int_size", typed_value)
                          {typed_value, <<typed_value::signed-integer-size(size)>>}
                        end
                      :error -> {nil, nil}
                    end
                  "string-float" ->
                    case (value |> String.trim() |> Float.parse()) do
                      {typed_value, _} ->
                        {typed_value, <<typed_value::float>>}
                      :error -> {nil, nil}
                    end
                  "string-ascii" ->
                    {value, value}
                  "hex-int" ->
                    bin = function("hex_2_binary", value)
                    size = bit_size(bin)
                    <<typed_value::signed-size(size)>> = bin
                    {typed_value, bin}
                  "hex-uint" ->
                    bin = function("hex_2_binary", value)
                    size = bit_size(bin)
                    <<typed_value::unsigned-size(size)>> = bin
                    {typed_value, bin}
                  "hex-float" ->
                    bin = function("hex_2_binary", value)
                    case byte_size(bin) do
                      4 ->
                        <<typed_value::float-size(32)>> = bin
                        {typed_value, bin}
                      8 ->
                        <<typed_value::float-size(64)>> = bin
                        {typed_value, bin}
                      _ ->
                        size = bit_size(bin)
                        <<typed_value::signed-size(size)>> = bin
                        {typed_value/1, <<typed_value::float>>}
                    end
                  _ ->
                    {nil, nil}
                end
              true ->
                {value, value}
            end
            function("save_tag_value", %{"value" => value, "valueType" => valueType, "typed_value" => typed_value, "typed_binary" => typed_binary, "path" => path})
            Log.info("function: transform: typed_value: #{inspect typed_value}")
            Log.info("function: transform: typed_binary: #{inspect typed_binary}")
            {typed_value, typed_binary}
      parse_condition:
        logic:
          $action: "elixir"
          value: |
            v |> Enum.filter(fn {key, _value} ->
              !String.starts_with?(key, "_")
            end) |> Enum.map(fn {key, value} ->
              cond do
                is_binary(value) -> {key, function("parse", %{"logic" => value, "allow_char" => true})}
                true -> {key, value}
              end
            end) |> Enum.into(%{})
      handleType:
        logic:
          $action: "elixir"
          value: |
            case v do
              %{"from" => "integer", "to" => "text"} -> inspect(v["value"])
              %{"from" => "number", "to" => "text"} -> inspect(v["value"])
              %{"from" => "text", "to" => "integer"} ->
                case Integer.parse(v["value"]) do
                  {val, _} -> val
                  _ -> v["value"]
                end
              %{"from" => "text", "to" => "number"} ->
                case Integer.parse(v["value"]) do
                  {val, _} -> val
                  _ -> v["value"]
                end
              %{"from" => "text", "to" => "float"} ->
                case Float.parse(v["value"]) do
                  {val, _} -> val
                  _ -> v["value"]
                end
              %{"from" => "text", "to" => "int"} ->
                case Integer.parse(v["value"]) do
                  {val, _} -> val
                  _ -> v["value"]
                end
              %{"from" => "text", "to" => "uint"} ->
                case Integer.parse(v["value"]) do
                  {val, _} -> val
                  _ -> v["value"]
                end
              _ -> v["value"]
            end
      parse:
        logic:
          $action: "elixir"
          value: |
            # in: logic:String
            # out: String
            require Integer
            logic = v["logic"] || ""
            logic |> String.split(["{", "}"]) |> Enum.with_index() |> Enum.map(fn {val, index} ->
              if (Integer.is_odd(index)) do
                arg = val |> String.split([",", "."]) |> Enum.map(fn x -> String.trim(x) end)
                case arg do
                  ["fn", "unique"] -> :rand.uniform(256)
                  ["action", category, group, device, tag, "binary"] -> get(["binary", "action", category, group, device, tag])
                  ["action", category, device, tag, "binary"] -> get(["binary", "action", category, "", device, tag])
                  ["action", category, group, device, tag, "raw"] -> get(["raw", "action", category, group, device, tag])
                  ["action", category, device, tag, "raw"] -> get(["raw", "action", category, "", device, tag])
                  ["action", category, group, device, tag] -> get(["value", "action", category, group, device, tag])
                  ["action", category, device, tag] -> get(["value", "action", category, "", device, tag])
                  [category, group, device, tag, "binary"] -> get(["binary", "tag", category, group, device, tag])
                  [category, device, tag, "binary"] -> get(["binary", "tag", category, "", device, tag])
                  [category, group, device, tag, "raw"] -> get(["raw", "tag", category, group, device, tag])
                  [category, device, tag, "raw"] -> get(["raw", "tag", category, "", device, tag])
                  [category, group, device, tag] -> get(["value", "tag", category, group, device, tag])
                  [category, device, tag] -> get(["value", "tag", category, "", device, tag])
                  _ -> ""
                end |> inspect()
              else
                val
              end
            end) |> Enum.join()
      parse_and_eval:
        logic:
          $action: "elixir"
          value: |
            # in: logic:String, allow_char:Boolean
            # out: Term
            parsed = function("parse", v)
            {ret, _} = if (v["allow_char"]) do
              Code.eval_string(parsed,[], __ENV__)
            else
              if String.match?(parsed, ~r/[a-zA-Z]/), do: {:error, "non arithmetic expression"}, else: Code.eval_string(parsed)
            end
            ret
      _DB/populate devices:
        logic:
          $action: "elixir"
          value: |
            devices = v["devices"] || []
            devices |> Enum.each(fn x ->
              properties = x["properties"] || %{}
              group = properties["group"] || ""
              category = properties["category"] || ""
              key = category <> "_" <> group <> "_" <> x["name"]
              query = """
              INSERT INTO devices (device_name, device_key)
              SELECT * FROM (SELECT '#{x["name"]}', '#{key}') AS tmp
              WHERE NOT EXISTS (
                SELECT * FROM devices
                WHERE device_key = '#{key}'
              )
              """
              Log.info("populate devices: query: " <> inspect(query))
              device_insert_result = instance(v["instance"], "query", query)
              Log.info("populate devices: device_insert_result: " <> inspect(device_insert_result))
              property_insert_result = case device_insert_result do
                {:ok, result} ->
                  num_rows = Map.get(result, :num_rows)
                  cond do
                    num_rows == 1 ->
                      last_insert_id = Map.get(result, :last_insert_id)
                      properties |> Enum.each(fn {x,y} ->
                        property_value = cond do
                          is_binary(y) -> y
                          is_map(y) -> Poison.encode!(y)
                          true -> inspect(y)
                        end
                        property_insert_query = """
                        INSERT INTO device_properties (device_id, property_name, property_value) VALUES (#{last_insert_id}, '#{x}', '#{property_value}')
                        ON DUPLICATE KEY UPDATE property_value = '#{property_value}'
                        """
                        property_insert_result = instance(v["instance"], "query", property_insert_query)
                      end)
                    num_rows == 0 ->
                      get_device_id_query = """
                      SELECT device_id FROM devices
                      INNER JOIN device_properties
                      USING (device_id) where device_name = '#{x["name"]}' and property_name = 'group' and property_value = '#{group}'
                      """
                      device_id_info = instance(v["instance"], "query", get_device_id_query)
                      case device_id_info do
                        {:ok, %Mariaex.Result{columns: _, connection_id: _, last_insert_id: _, num_rows: _, rows: [[device_id]]}} ->
                          properties |> Enum.each(fn {x,y} ->
                            property_value = cond do
                              is_binary(y) -> y
                              is_map(y) -> Poison.encode!(y)
                              true -> inspect(y)
                            end
                            property_insert_query = """
                            INSERT INTO device_properties (device_id, property_name, property_value) VALUES (#{device_id}, '#{x}', '#{property_value}')
                            ON DUPLICATE KEY UPDATE property_value = '#{property_value}'
                            """
                            instance(v["instance"], "query", property_insert_query)
                          end)
                        _ -> :ok
                      end
                    true -> :ok
                  end
                error -> Log.info("populate devices: error: " <> inspect(error))
              end
            end)
      _DB/populate tags:
        logic:
          $action: "elixir"
          value: |
            Log.info("populate tags: v: " <> inspect(v))
            tags = v["tags"] || []
            tags |> Enum.each(fn x ->
              Log.info("populate tags: x: " <> inspect(x))
              properties = x["properties"] || %{}
              group = properties["_group"] || ""
              device = properties["_device"] || ""
              category = properties["_category"] || ""
              key = category <> "_" <> group <> "_" <> device
              Log.info("populate tags: key: " <> inspect(key))
              get_device_id_query = """
              SELECT device_id FROM devices
              where device_key = '#{key}'
              """
              Log.info("populate tags: get_device_id_query: " <> inspect(get_device_id_query))
              device_id_info = instance(v["instance"], "query", get_device_id_query)
              Log.info("populate tags: device_id_info: " <> inspect(device_id_info))
              case device_id_info do
                {:ok, %Mariaex.Result{columns: _, connection_id: _, last_insert_id: _, num_rows: _, rows: [[device_id]]}} ->
                  query = """
                  INSERT INTO tag (tag_name, tag_value_type, device_id) VALUES ('#{x["name"]}', '#{x["value_type"]}', #{device_id})
                  ON DUPLICATE KEY UPDATE tag_value_type = '#{x["value_type"]}'
                  """
                  tag_insert_result = instance(v["instance"], "query", query)
                  property_insert_result = case tag_insert_result do
                    {:ok, result} ->
                      # num_rows = Map.get(result, :num_rows)
                      last_insert_id = Map.get(result, :last_insert_id)
                      cond do
                        last_insert_id != 0->
                          set(["tag_id", category, group, device, x["name"]], last_insert_id)
                          properties |> Enum.each(fn {x,y} ->
                            property_value = cond do
                              is_binary(y) -> y
                              is_map(y) -> Poison.encode!(y)
                              true -> inspect(y)
                            end
                            property_insert_query = """
                            INSERT INTO tag_properties (tag_id, property_name, property_value) VALUES (#{last_insert_id}, '#{x}', '#{property_value}')
                            ON DUPLICATE KEY UPDATE property_value = '#{property_value}'
                            """
                            instance(v["instance"], "query", property_insert_query)
                          end)
                        last_insert_id == 0 ->
                          get_tag_id_query = """
                          SELECT tag_id FROM tag
                          where tag_name = '#{x["name"]}' and device_id = #{device_id}
                          """
                          tag_id_info = instance(v["instance"], "query", get_tag_id_query)
                          case tag_id_info do
                            {:ok, %Mariaex.Result{columns: _, connection_id: _, last_insert_id: _, num_rows: _, rows: [[tag_id]]}} ->
                              set(["tag_id", category, group, device, x["name"]], tag_id)
                              properties |> Enum.each(fn {x,y} ->
                                property_value = cond do
                                  is_binary(y) -> y
                                  is_map(y) -> Poison.encode!(y)
                                  true -> inspect(y)
                                end
                                property_insert_query = """
                                INSERT INTO tag_properties (tag_id, property_name, property_value) VALUES (#{tag_id}, '#{x}', '#{property_value}')
                                ON DUPLICATE KEY UPDATE property_value = '#{property_value}'
                                """
                                instance(v["instance"], "query", property_insert_query)
                              end)
                            _ -> :ok
                          end
                        true -> :ok
                      end
                    _ -> :ok
                  end
                _ -> :ok
              end
            end)
      _DB/setup tables:
        logic:
          $action: "elixir"
          value: |
            ["""
            CREATE TABLE IF NOT EXISTS devices(
              device_id             INT           AUTO_INCREMENT PRIMARY KEY,
              device_key            VARCHAR(255)  NOT NULL,
              device_name           VARCHAR(255)  NOT NULL,
              created_at            TIMESTAMP     DEFAULT CURRENT_TIMESTAMP
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS device_properties(
              device_id             INT           NOT NULL,
              property_name         VARCHAR(255)  NOT NULL,
              property_value        VARCHAR(512)  DEFAULT '',
              UNIQUE KEY `key` (`device_id`,`property_name`)
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS tag(
              tag_id                INT           AUTO_INCREMENT PRIMARY KEY,
              device_id             INT           NOT NULL,
              tag_name              VARCHAR(255)  NOT NULL,
              tag_value_type        VARCHAR(16)   DEFAULT 'string',
              tag_value             TEXT,
              UNIQUE KEY `key` (`device_id`,`tag_name`)
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS tag_properties(
              tag_id                INT           NOT NULL,
              property_name         VARCHAR(255)  NOT NULL,
              property_value_type   VARCHAR(16)   DEFAULT 'string',
              property_value        VARCHAR(512)  DEFAULT '',
              UNIQUE KEY `key` (`tag_id`,`property_name`)
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS action_history(
              action_history_id        INT           AUTO_INCREMENT PRIMARY KEY,
              created_at            TIMESTAMP     DEFAULT CURRENT_TIMESTAMP,
              value                 TEXT          NOT NULL
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS tag_history(
              tag_history_id        INT           AUTO_INCREMENT PRIMARY KEY,
              tag_id                INT           NOT NULL,
              created_at            TIMESTAMP     DEFAULT CURRENT_TIMESTAMP,
              value                 TEXT          NOT NULL
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS clients(
              client_id             INT           AUTO_INCREMENT PRIMARY KEY,
              client_name           VARCHAR(255)  NOT NULL,
              created_at            TIMESTAMP     DEFAULT CURRENT_TIMESTAMP
            );
            """,
            """
            CREATE TABLE IF NOT EXISTS client_properties(
              client_id             INT           NOT NULL,
              property_name         VARCHAR(255)  NOT NULL,
              property_value        VARCHAR(512)  DEFAULT '',
              UNIQUE KEY `key` (`client_id`,`property_name`)
            );
            """] |> Enum.map(fn x ->
              instance(v["instance"], "query", x)
            end)
      map:
        logic:
          $action: "elixir"
          value: |
            Log.info("map: #{inspect v}")
            mappings = get("mappings") || []
            Log.info("map: mappings: #{inspect mappings}")
            mappings |> Enum.find(fn x ->
              v["key"] == {x["from"]["name"], x["from"]["device"], x["from"]["group"]}
            end) |> case do
              nil ->
                Log.info("map: no matching mapping")
                :ok
              mapping ->
                Log.info("map: mapping: #{inspect mapping}")
                from = mapping["from"] || %{}
                to = mapping["to"] || %{}
                tags = get("tags") || []
                key = {to["name"], to["device"], to["group"]}
                tags |> Enum.find(fn x ->
                  key == {x["name"], x["properties"]["_device"], x["properties"]["_group"]}
                end) |> case do
                  nil -> :ok
                  tag ->
                    new_condition = function("parse_condition", tag["properties"]["_condition"])
                    arg = tag["properties"] |> Map.put("value", v["value"]) |> Map.put("_condition", new_condition)
                    case to["action"] do
                      "read" -> instance(to["group"] <>"/" <> to["device"], "read_tag", arg)
                      "write" -> instance(to["group"] <>"/" <> to["device"], "write_tag", arg)
                      _ -> instance(to["group"] <>"/" <> to["device"], "read_tag", arg)
                    end
                end
            end
    type: "string"
  service:
    default: |
      http client:
        function:
          get:
            data:
              - "url"
            logic:
              $action: "elixir"
              value: |
                Log.info("http client: " <> inspect v)
                req = get()
                Log.info("http client: req: " <> inspect req)
                # Service.Http.get(v["url"])
          write_tag:
            logic:
              $action: "elixir"
              value: |
                Log.info("http client: write: v: " <> inspect v)
                data = get()
                Log.info("http client: write: data: " <> inspect data)
                # Check data["url"] and replace all variable from v
                url = data["url"] |> Utils.Data.string_var_replace("{", "}", v)
                Log.info("http client: write: url: " <> inspect url)
                value = cond do
                  is_binary(v["value"]) -> v["value"]
                  true -> inspect v["value"]
                end
                Service.Http.put(url, value)
          read_tag:
            logic:
              $action: "elixir"
              value: |
                Log.info("http client: read: v: " <> inspect v)
                data = get()
                Log.info("http client: read: data: " <> inspect data)
                # Check data["url"] and replace all variable from v
                url = data["url"] |> Utils.Data.string_var_replace("{", "}", v)
                Log.info("http client: url: " <> inspect url)
                Service.Http.get(url)
    type: "string"
description: "EdgeHub Engine Project"
function:
  clean up:
    logic:
      $action: "elixir"
      value: |
        project = "edgehub_solution_default"
        delete_conf([], project)
        function("instance stop all", %{"project" => project})
        compile(project)
        set_version(project)
  compile:
    logic:
      $action: "elixir"
      value: |
        # Initialize
        set("edgehub_db_list", [])
        project = "edgehub_solution_default"
        config = get("config") || %{}
        devices = config["devices"] || []
        protocols = config["protocols"] || []
        interactor_config = %{}
        config_string = cond do
          is_map(config) -> Poison.encode!(config)
          is_binary(config) -> config
          true -> ""
        end

        service_builtin_map = case get_conf(["service"], project: "edgehub") do
          {:ok, service_builtin} -> service_builtin
          _ -> %{}
        end

        # Create service
        service = get("service") |> Yaml.Decoder.read_from_string!() |> Map.merge(service_builtin_map)
        custom_service = function("compile service", project: project, protocols: protocols)
        Log.info("compile: custom_service: #{inspect custom_service}")
        service = service |> Map.merge(custom_service)

        # Create instances
        timer_instances = function("compile tag", project: project, tag_map: config["tags"], interactor_config: interactor_config)
        device_instances = function("compile device", project: project, devices: devices, interactor_config: interactor_config, custom_service: custom_service |> Enum.map(fn {k,v} -> k end))
        instances = device_instances |> Map.merge(timer_instances)

        # Create Data
        stat_device_data = device_instances |> Map.keys() |> Enum.reduce(%{}, fn x, acc ->
          %{
            x => %{
              "sent_count" => 0,
              "received_count" => 0,
              "error_count" => 0,
              "continuous_error_count" => 0
            } |> Map.merge(acc)
          }
        end)

        edgehub_db_list = get("edgehub_db_list")
        Log.info("compile: edgehub_db_list: #{inspect edgehub_db_list}")

        data = %{
          "mappings" => %{
            "default" => config["mappings"]
          },
          "tags" => %{
            "default" => config["tags"]
          },
          "actions" => %{
            "default" => config["actions"]
          },
          "config" => %{
            "default" => config_string
          },
          "edgehub_db_list" => %{
            "default" => edgehub_db_list
          },
          "stat" => %{
            "device" => stat_device_data
          }
        }

        # Create interactor configuration
        interactor_config =
          %{"instance" => instances}
          |> Map.put("data", data)
          |> Map.put("service", service)
          |> Map.put("function", get("function") |> Yaml.Decoder.read_from_string!())

        # Configure and compile
        Log.info("compile: interactor_config: #{inspect(interactor_config)}")
        # delete_conf([], project: project)
        clear([], project: project)
        function("instance stop all", %{"project" => project})
        interactor_config |> put_conf([], project: project)
        :timer.sleep(10)
        compile(project)
        set_version(project)
        function("instance start all", %{"project" => project})
  compile device:
    logic:
      $action: "elixir"
      value: |
        Log.info("compile device: #{inspect(v)}")
        project = v[:project] || "edgehub_solution_default"
        devices = v[:devices] || []
        custom_service = v[:custom_service] || []
        global_services = case get_conf(["service"], project: "__GLOBAL__") do
          {:ok, nil} -> []
          {:ok, config} -> config |> Map.keys()
          _ -> []
        end
        local_services = case get_conf(["service"], project: "edgehub") do
          {:ok, nil} -> []
          {:ok, config} -> config |> Map.keys()
          _ -> []
        end

        services = Interactor.Instance.built_in_services() ++ global_services ++ local_services ++ custom_service
        Log.info("compile device: services: #{inspect services}")
        instance_configuration =
          devices
          |> Enum.reduce(%{}, fn x, acc ->
            Log.info("compile device: x: #{inspect x}")
            properties = x["properties"] || %{}
            group = properties["group"] || ""
            key = group <> "/" <> x["name"]
            communication = properties["communication"] || %{}
            event = %{
              "write" => %{
                "$action" => "elixir",
                "value" => """
                  Log.info("write: triggered: #{key}: \#{inspect v}")
                  Log.info("write: triggered: randomness: #{inspect :rand.uniform(1000)}")
                  path = v["path"]
                  Log.info("write: triggered: #{key}: path: \#{inspect path}")
                  value = v["value"]
                  Log.info("write: triggered: #{key}: value: \#{inspect value}")
                  tags = get("tags") || []
                  if (path) do
                    Log.info("write: triggered: #{key}: object write:")
                    tags |> Enum.filter(fn x ->
                      Log.info("write: triggered: #{key}: x: \#{inspect x}")
                      group = x["properties"]["_group"] || ""
                      x_path = ["tag", x["properties"]["_category"], group, x["properties"]["_device"], x["name"]]
                      Log.info("write: triggered: #{key}: x_path: \#{inspect x_path}")
                      x_path == path
                    end)
                  else
                    tags |> Enum.filter(fn x ->
                      group = x["properties"]["_group"] || ""
                      (x["idFields"] == v["idFields"]) && (#{inspect group} == group) && (x["properties"]["_device"] == #{inspect x["name"]})
                    end)
                  end |> Enum.each(fn y -> # y: tags to be processed
                    Log.info("write: triggered: #{key}: y: \#{inspect y}")
                    case y["properties"]["_category"] do
                      "virtual" ->
                        Log.info("write: triggered: #{key}: virtual:")
                        function("transform", %{"value" => value["value"], "type" => y["properties"]["_condition"]["valueType"], "path" => path})
                      "device" ->
                        Log.info("write: triggered: #{key}: device:")
                        tag = tags |> Enum.find(fn z ->
                          Log.info("write: triggered: #{key}: z: \#{inspect z}")
                          (z["properties"]["_group"] == y["properties"]["_condition"]["group"]) && (z["properties"]["_device"] == y["properties"]["_condition"]["device"]) && (z["name"] == y["properties"]["_condition"]["tag"])
                        end)
                        Log.info("write: triggered: #{key}: tag: \#{inspect tag}")
                        instance_name = if (tag["properties"]["communication"]["serial"]) do
                          "Serial_Port_" <> tag["properties"]["communication"]["data"]["port"]
                        else
                          "\#{y[\"properties\"][\"_condition\"][\"group\"]}/\#{y[\"properties\"][\"_condition\"][\"device\"]}"
                        end
                        # instance_name = "\#{y[\"properties\"][\"_condition\"][\"group\"]}/\#{y[\"properties\"][\"_condition\"][\"device\"]}"
                        Log.info("write: triggered: #{key}: instance_name: \#{inspect instance_name}")
                        new_condition = function("parse_condition", tag["properties"]["_condition"])
                        result = instance(instance_name, "write_tag", %{"properties" => tag["properties"] |> Map.put("_condition", new_condition), "value" => v["value"]})
                        Log.info("write: triggered: #{key}: result: \#{inspect result}")
                    end
                  end)
                """
              }
            }
            database_connected_event = %{
              "connected" => %{
                "$action" => "elixir",
                "value" => """
                  Log.info("_DB: connected: \#{inspect v}")
                  function("_DB/setup tables", %{"instance" => #{inspect key}})
                  config_string = get("config") || "{}"
                  config = cond do
                    is_binary(config_string) -> Poison.decode!(config_string)
                    true -> %{}
                  end
                  devices = config["devices"] || []
                  tags = config["tags"] || []
                  function("_DB/populate devices", %{"devices" => devices, "instance" => #{inspect key}})
                  function("_DB/populate tags", %{"tags" => tags, "instance" => #{inspect key}})
                """
              }
            }
            http_server_received_event = %{
              "received" => %{
                "$action" => "elixir",
                "value" => """
                  Log.info("EdgeHub HTTP Server: \#{inspect v}")
                  [_|paths] = v["path"] |> String.split("/")
                  path = case paths do
                    [type, "virtual", device, tag] -> [type, "virtual", "", device, tag]
                    [type, "database", device, tag] -> [type, "database", "", device, tag]
                    _ -> paths
                  end
                  case v["method"] do
                    "PUT" ->
                      value = case Poison.decode(v["body"]) do
                        {:error, %Poison.ParseError{}} -> v["body"]
                        {:ok, map} -> map
                      end
                      set(["value"] ++ path, value)
                      %{"result" => "success"}
                    _ -> %{"result" => "success", "value" => get(["value"] ++ path)}
                  end |> Poison.encode!()
                """
              }
            }
            cond do
              communication["serial"] ->
                Log.info("compile device: serial device: " <> inspect(key))
                # Check if there is existing instance with same port id
                port_name = "Serial_Port_" <> communication["data"]["port"]
                if (acc |> Map.keys() |> Enum.member?(port_name)) do
                  Log.info("compile device: serial device: exists: ")
                  acc
                else
                  Log.info("compile device: serial device: new: ")
                  acc
                  |> Map.put(port_name, %{
                    "use" => communication["service"],
                    "data" => communication["data"],
                    "event" => event
                  })
                end
              Enum.member?(services, communication["service"]) ->
                event = cond do
                  ((communication["service"] == "mariadb") && (communication["data"]["type"] == "edgehub")) ->
                    edgehub_db_list = get("edgehub_db_list") || []
                    set("edgehub_db_list", edgehub_db_list ++ [key], flatten: true)
                    event |> Map.merge(database_connected_event)
                  (communication["service"] == "http server") ->
                    event |> Map.merge(http_server_received_event)
                  true ->
                    event
                end
                acc
                |> Map.put(key, %{
                  "use" => communication["service"],
                  "data" => communication["data"],
                  "event" => event
                })
              true ->
                acc
            end
          end)

        Log.info("compile device: instance_configuration: #{inspect(instance_configuration)}")
        instance_configuration
  compile service:
    logic:
      $action: "elixir"
      value: |
        Log.info("compile service: #{inspect(v)}")
        project = v[:project] || "edgehub_solution_default"
        protocols = v[:protocols] || []

        service_configuration =
          protocols
          |> Enum.filter(fn {protocol_name, protocol_config} -> (protocol_config["builtIn"] != true) && (protocol_config["service"] != nil) end)
          |> Enum.map(fn {protocol_name, protocol_config} ->
            Log.info("compile service: custom: protocol_name: " <> protocol_name)
            Log.info("compile service: custom: protocol_config: " <> inspect(protocol_config))
            connectionInfo = protocol_config["connectionInfo"] || []
            Log.info("compile service: custom: connectionInfo: " <> inspect(connectionInfo))

            # Configure Data
            data = connectionInfo |> Enum.map(fn x ->
              {x["key"], %{
                  "input" => true,
                  "required" => true,
                  "type" => x["valueType"] || "string",
                  "default" => x["default"] || ""
                }
              }
            end) |> Enum.into(%{})
            Log.info("compile service: custom: data: " <> inspect(data))

            # Configure Function
            read_tag_map_string = case protocol_config["service"] do
              "port" ->
                (protocol_config["tagInfo"] |> Enum.reduce("tagInfo = %{\r\n", fn info, acc ->
                  acc <>
                  """
                    "#{info["key"]}" => v["_condition"]["#{info["key"]}"],
                  """
                  <> "\r\n"
                end)) <>
                """
                }
                Log.info("#{protocol_name}: function: read_tag: tagInfo: " <> inspect(tagInfo))
                map = %{"command" => "read_tag", "tagInfo" => tagInfo}
                Log.info("#{protocol_name}: function: read_tag: map: " <> inspect(map))
                data = case Poison.encode(map) do
                  {:ok, d} -> d <> "\n"
                  error -> "{}\n"
                end
                Log.info("#{protocol_name}: function: read_tag: data: " <> inspect(data))
                """
              _ ->
                (protocol_config["readrequestfields"] |> Enum.reduce("map = %{\r\n", fn x, acc ->
                  Log.info("compile service: custom: x: #{inspect(x)}")
                  field_string = case x["sourceType"] do
                    "set" ->
                      """
                        "#{x["name"]}" => function("handleType", %{
                          "from" => "text",
                          "to" => "#{x["type"]}",
                          "value" => function("parse", %{
                            "logic" => "#{x["set"]}",
                            "allow_char" => true
                          })
                        }),
                      """
                    "dynamic" ->
                      case x["source"] do
                        "connectionInfo" ->
                          conn_info = connectionInfo |> Enum.find(fn info -> info["key"] == x["info"] end) || {}
                          from = conn_info["valueType"] || "text"
                          """
                            "#{x["name"]}" => function("handleType", %{
                              "from" => "#{from}",
                              "to" => "#{x["type"]}",
                              "value" => get("#{x["info"]}")
                            }),
                          """
                        "tagInfo" ->
                          tagInfo = protocol_config["tagInfo"] || []
                          tag_info = tagInfo |> Enum.find(fn info -> info["key"] == x["info"] end) || {}
                          from = tag_info["valueType"] || "text"
                          """
                            "#{x["name"]}" => function("handleType", %{
                              "from" => "#{from}",
                              "to" => "#{x["type"]}",
                              "value" => v["_condition"]["#{x["info"]}"]
                            }),
                          """
                        _ -> ""
                      end
                    _ -> ""
                  end
                  acc <> field_string <> "\r\n"
                end)) <>
                """
                }
                encoded = encode(map, "#{protocol_config["readrequest"]}")
                Log.info("#{protocol_name}: function: read_tag: encoded: " <> inspect(encoded))
                data = encoded |> Map.get(:result)
                Log.info("#{protocol_name}: function: read_tag: data: " <> inspect(data))
                """
            end
            read_tag = """
            Log.info("#{protocol_name}: function: read_tag: v: " <> inspect(v))
            Log.info("#{protocol_name}: function: read_tag: randomness: #{inspect :rand.uniform(1000)}")
            """ <> read_tag_map_string <> case protocol_config["service"] do
              "tcp" -> "result = Service.Tcp.send_and_recv(get(\"address\"), get(\"port\"), data) "
              "port" ->
                """
                send_id = :rand.uniform(1_000_000)
                instance("custom", "send", %{"data" => data, "id" => send_id})
                Log.info("#{protocol_name}: function: read_tag: send_id: " <> inspect(send_id))
                result = Enum.find_value(1..20000, <<>>, fn x ->
                  :timer.sleep(1)
                  received = instance("custom", "check received", send_id)
                  if (received == ""), do: false, else: {:port, received}
                end)
                """
              _ -> "result = instance(\"custom\", \"send\", data) "
            end <> """
            |> case do
              {:ok, ret} ->
                decoded = decode(ret, "response")
                {:ok, decoded |> Map.get(:result) |> Map.get("#{protocol_config["readresponsefield"]}")}
              {:port, ret} ->
                {:ok, Poison.decode!(ret) |> Map.get("value")}
              error ->
                {:error, error}
            end
            Log.info("#{protocol_name}: function: read_tag: result: " <> inspect(result))
            result
            """
            Log.info("compile service: custom: read_tag: \r\n" <> read_tag)
            function = %{
              "read_tag" => %{
                "logic" => %{
                  "$action" => "elixir",
                  "value" => read_tag
                }
              }
            }
            Log.info("compile service: custom: function: " <> inspect(function))

            use = case protocol_config["service"] do
              "tcp" -> "tcp client"
              "serial" -> "serial"
              "port" -> "port"
              other -> other
            end
            Log.info("compile service: custom: use: " <> inspect(use))


            # Configure Model
            config = protocol_config["config"] || %{}
            models = config["model"] || %{}
            Log.info("compile service: custom: models: \r\n" <> inspect(models))

            model = models |> Enum.reduce([], fn {model_name, model_config}, acc ->
              Log.info("compile service: model_name: #{inspect(model_name)}")
              Log.info("compile service: model_config: #{inspect(model_config)}")
              fields = model_config["fields"] || []
              case fields do
                [] -> acc
                _ ->
                  new_config = {model_name, %{
                    "$parser" => "binary",
                    "rand" => :rand.uniform(1000),
                    "fields" => fields |> Enum.map(fn field ->
                      Log.info("compile service: field: #{inspect(field)}")
                      size = case Integer.parse(field["size"]) do
                        {x, _} -> x
                        :error ->
                          %{
                            "$action" => "elixir",
                            "value" => "v[" <> inspect(field["size"]) <> "]"
                          }
                      end
                      %Elixir.Compiler.Model.Binary.Struct.Field{
                        name: field["name"],
                        size: size,
                        type: field["type"],
                        options: field["options"]
                      }
                    end)
                  }}
                  Log.info("compile service: new_config: #{inspect(new_config)}")
                  acc ++ [new_config]
              end
            end) |> Enum.into(%{})
            Log.info("compile service: model: #{inspect(model)}")

            instance_data = case protocol_config["service"] do
              "tcp" -> ["address", "port"]
              "serial" -> ["port", "speed", "data_bits", "stop_bits", "parity", "framing", "framing_separator", "framing_timeout", "models"]
              "port" -> ["executable", "args", "packet", "type"]
            end |> Enum.map(fn key ->
              {key, %{
                "$action" => "elixir",
                "value" => "get(\"#{key}\")"
              }}
            end) |> Enum.into(%{})
            Log.info("compile service: instance_data: #{inspect(instance_data)}")

            instance = %{
              "custom" => %{
                "data" => instance_data,
                "use" => use
              }
            }
            Log.info("compile service: instance: #{inspect(instance)}")

            # Configure service
            service_config = %{
              "data" => data,
              "function" => function,
              "model" => model,
              "instance" => instance
            }
            {protocol_name, service_config}
          end) |> Enum.into(%{})

        Log.info("compile service: service_configuration: #{inspect(service_configuration)}")
        service_configuration
  compile tag:
    logic:
      $action: "elixir"
      value: |
        Log.info("compile tag: #{inspect(v)}")
        tag_map = v[:tag_map] || %{}

        timers =
          tag_map
          |> Enum.reduce(%{}, fn value, acc ->
            Log.info("compile tag: tag: #{inspect value["name"]}")
            if (value["properties"]["_condition"]["_interval"]) do
              category = if value["properties"]["_category"], do: value["properties"]["_category"], else: ""
              group = if value["properties"]["_group"], do: value["properties"]["_group"], else: ""
              device = if value["properties"]["_device"], do: value["properties"]["_device"], else: ""
              instance_name = "__timer_" <> category <> "_" <> group <> "_" <> device <> "_" <> inspect(value["properties"]["_condition"]["_interval"]) <> "ms"
              if acc[instance_name] do
                tags = acc[instance_name]["data"]["tags"] ++ [value]
                acc |> Interactor.Object.put_in([instance_name, "data", "tags"], tags)
              else
                acc |> Map.put(instance_name, %{
                  "use" => "timer",
                  "data" => %{
                    "priority" => "low",
                    "interval" => value["properties"]["_condition"]["_interval"],
                    "tags" => [value],
                    "value" => %{}
                  },
                  "event" => %{
                    "execute" => %{
                      "$action" => "elixir",
                      "value" => """
        Log.info("timer: #{instance_name}: triggered: \#{inspect v}")
        Log.info("timer: #{instance_name}: randomness: #{inspect :rand.uniform(1000)}")
        if (v["count"] > 1) do
          tags = v["data"][:config]["tags"] || []
          result = tags |> Enum.map(fn x ->
            try do
              Log.info("timer: #{instance_name}: processing tag: \#{inspect x}")
              category = x["properties"]["_category"] || ""
              group = x["properties"]["_group"]
              device = x["properties"]["_device"] || ""
              condition = x["properties"]["_condition"] || %{}
              case category do
                "virtual" ->
                  ret = function("parse_and_eval", %{"logic" => x["properties"]["_condition"]["logic"], "allow_char" => true})
                  {typed_value, typed_binary} = function("transform", %{"value" => ret, "type" => x["properties"]["_condition"]["valueType"], "path" => ["tag", category, group || "", device, x["name"]]})
                  tags = get("tags") || []
                  server_tags = tags |> Enum.filter(fn y ->
                    (y["properties"]["_condition"]["category"] === "virtual") && (y["properties"]["_condition"]["device"] === "Virtual") && (y["properties"]["_condition"]["tag"] === x["name"])
                  end) |> Enum.each(fn z ->
                    instance("\#{z[\"properties\"][\"_group\"]}/\#{z[\"properties\"][\"_device\"]}", "write_mem", %{"tag" => z, "bin" => typed_binary, "value" => typed_value})
                  end)
                  action_results = function("execute_actions", %{"tag" => x, "value" => typed_value})
                  db_result = function("db_put", %{"tag" => x, "value" => ret})
                  Log.info("timer: #{instance_name}: virtual: action_results: \#{inspect action_results}")
                  ret
                _ ->
                  Log.info("timer: #{instance_name}: instance name: \#{x[\"properties\"][\"_group\"]}/\#{x[\"properties\"][\"_device\"]}")
                  target_instance = if (x["properties"]["communication"]["serial"]) do
                    "Serial_Port_" <> x["properties"]["communication"]["data"]["port"]
                  else
                    "\#{x[\"properties\"][\"_group\"]}/\#{x[\"properties\"][\"_device\"]}"
                  end
                  count(["stat",target_instance,"sent_count"], 1)
                  new_condition = function("parse_condition", condition)
                  case instance(target_instance, "read_tag", x["properties"] |> Map.put("_name", x["name"]) |> Map.put("_condition", new_condition)) do
                    {:ok, response} ->
                      count(["stat",target_instance,"received_count"], 1)
                      set(["stat",target_instance,"continuous_error_count"], 0)
                      {typed_value, typed_binary} = function("transform", %{"value" => response, "type" => x["properties"]["_condition"]["valueType"], "path" => ["tag", category, group || "", device, x["name"]]})
                      tags = get("tags") || []
                      server_tags = tags |> Enum.filter(fn y ->
                        (y["properties"]["_condition"]["group"] === group) && (y["properties"]["_condition"]["device"] === device) && (y["properties"]["_condition"]["tag"] === x["name"])
                      end) |> Enum.each(fn z ->
                        instance("\#{z[\"properties\"][\"_group\"]}/\#{z[\"properties\"][\"_device\"]}", "write_mem", %{"tag" => z, "bin" => typed_binary, "value" => typed_value})
                      end)
                      action_results = function("execute_actions", %{"tag" => x, "value" => typed_value})
                      db_result = function("db_put", %{"tag" => x, "value" => typed_value})
                      response
                    error ->
                      Log.warn("#{instance_name}: error: \#{inspect error}")
                      count(["stat",target_instance,"error_count"], 1)
                      count(["stat",target_instance,"continuous_error_count"], 1)
                      ""
                  end
              end
            rescue
              e -> Log.error("EdgeHub: Action: Error: read_tag: " <> inspect e)
            end
          end)
          Log.info("#{instance_name}: result: \#{inspect result}")
        end
                      """
                    }
                  }
                })
              end
            else
              acc
            end
          end)
        Log.info("timers: #{inspect(timers)}")
        timers
  imap:
    logic:
      $action: "elixir"
      value: |
        Utils.Transform.map(get(["imap"]), get(["config"]))
  instance start:
    logic:
      $action: "elixir"
      value: |
        Log.info("instance start: #{inspect(v)}")
        Interactor.Instance.start(v["path"] |> Enum.at(-1), Execution.State.new(v["project"]))
  instance start all:
    logic:
      $action: "elixir"
      value: |
        Log.info("instance start all: #{inspect(v)}")
        Interactor.Instance.start(:all, Execution.State.new(v["project"]))
  instance stop:
    logic:
      $action: "elixir"
      value: |
        Log.info("instance stop: #{inspect(v)}")
        Interactor.Instance.stop(v["path"] |> Enum.at(-1), Execution.State.new(v["project"]))
  instance stop all:
    logic:
      $action: "elixir"
      value: |
        Log.info("instance stop all: #{inspect(v)}")
        Interactor.Instance.stop(:all, Execution.State.new(v["project"]))
  read_file:
    logic:
      $action: "elixir"
      value: |
        File.read!(get("base_dir") <> v["dir"])
  respond:
    logic:
      $action: "elixir"
      value: |
        cond do
          is_binary(v) ->
            %{"headers" => %{"Content-Type" => "application/json"}}
            |> Map.put("body", v)
          is_map(v) ->
            case v do
              %{"headers" => headers} ->
                h = headers |> Map.put("Content-Type", "application/json")
                v |> Map.put("headers", h)
              %{:headers => headers} ->
                h = headers |> Enum.into(%{}) |> Map.put("Content-Type", "application/json")
                v |> Map.put("headers", h)
              _ ->
                Log.info("respond: map: any: #{inspect v}")
                %{"headers" => %{"Content-Type" => "application/json"}}
                |> Map.put("body", v |> ISON.encode() |> Poison.encode!())
            end
          true ->
            %{"headers" => %{"Content-Type" => "application/json"}}
            |> Map.put("body", v)
        end
  save config:
    logic:
      $action: "elixir"
      value: |
        config = get("config")
        Utils.Encryption.write("edgehub/client0.conf", "default" |> Base.encode64(), "Mr.Choi", config)
instance:
  api:
    data:
      port: 1290
    event:
      received:
        $action: "match"
        matches:
          - do:
              $action: "elixir"
              value: |
                resp = %{"status" => "success", "result" => get("admin")} |> Poison.encode!()
                function("respond", resp)
            model:
              $ref: "/api/admin/get"
          - do:
              $action: "elixir"
              value: |
                Log.info("/api/admin/set: #{inspect(v)}")
                set("admin", v["body"], flatten: true)
                resp = %{"status" => "success", "result" => "success"}
                function("respond", resp)
            model:
              $ref: "/api/admin/set"
          - do:
              $action: "elixir"
              value: |
                # Log.info("/api/add_first_user: #{inspect(v)}")

                resp = if(Table.Admin.get_all('user') == []) do
                  Utils.User.add(v["body"]["username"], v["body"]["password"])
                  %{"status" => "success", "result" => "User added"}
                else
                  %{"status" => "error", "result" => "Cannot add first user when users already exist"}
                end
                |> Poison.encode!()
                function("respond", resp)
            model:
              $ref: "/api/add_first_user"
          - do:
              $action: "elixir"
              value: |
                result = Table.Admin.get_all('user') == []
                resp = %{"status" => "success", "result" => result} |> Poison.encode!()
                function("respond", resp)
            model:
              $ref: "/api/is_first_user"
          - do:
              $action: "elixir"
              value: |
                resp = if(Utils.User.authenticate(v["body"]["username"], v["body"]["password"])) do
                  cookie = GenServer.call(UI.Cookies, {:add, v["body"]["username"]})
                  req = UI.Utils.set_header("set-cookie", [cookie |> UI.Utils.add_cookie_suffix()], v)

                  req =
                    %{"headers" => %{"set-cookie" => [cookie |> UI.Utils.add_cookie_suffix()]}}
                    |> Map.put("body", %{"status" => "success", "result" => v["body"]["username"]})

                  req
                else
                  %{"status" => "error", "result" => "invalid"}
                end
                function("respond", resp)
            model:
              $ref: "/api/login"
          - do:
              $action: "elixir"
              value: |
                cookie = GenServer.call(UI.Cookies, {:delete, v["headers"]["cookie"]})

                req =
                  %{"headers" => %{"set-cookie" => [cookie |> UI.Utils.add_cookie_suffix()]}}
                  |> Map.put("body", %{"status" => "success", "result" => "logged out"})
            model:
              $ref: "/api/logout"
          - do:
              $action: "elixir"
              value: |
                set("config", get("defaultConfig"), flatten: true)
                body = %{"status" => "success", "result" => get("config")} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/config/clear"
          - do:
              $action: "elixir"
              value: |
                body = %{"status" => "success", "result" => get("defaultConfig")} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/config/default"
          - do:
              $action: "elixir"
              value: |
                Log.info("config/get: " <> inspect(v))
                Log.info("config/get: config: " <> inspect(get("config")))
                body = %{"status" => "success", "result" => get("config")} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/config/get"
          - do:
              $action: "elixir"
              value: |
                body = cond do
                  is_map(v["body"]) ->
                    set("config", v["body"], flatten: true)
                    # function("compile")
                    %{"status" => "success", "result" => "success"} |> Poison.encode!()
                  true ->
                    %{"status" => "error", "result" => "Incorrect configuration structure"} |> Poison.encode!()
                end
                function("respond", body)
            model:
              $ref: "/api/config/set"
          - do:
              $action: "elixir"
              value: |
                # Log.info("/api/log/get: #{inspect(v)}")
                logs = Interactor.Log.get(v["body"])

                body = %{"status" => "success", "result" => %{"logs" => logs}} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/log/get"
          - do:
              $action: "elixir"
              value: |
                # Log.info("/api/log/clear: #{inspect(v)}")
                Interactor.Log.clear_logs()

                function("respond", %{"status" => "success", "result" => %{}})
            model:
              $ref: "/api/log/clear"
          - do:
              $action: "elixir"
              value: |
                license =
                  case(Table.System.get_value("license")) do
                    :no_record ->
                      %{
                        "active_rules" => %{"usage_interval" => "86400", "usage_max" => "1"},
                        "type_info" => %{"license_type_name" => "Trial"},
                        "license_info" => %{"license_expiry" => 0}
                      }

                    license ->
                      license
                  end

                result = %{
                  "version" =>
                    case(:application.get_key(:interactor, :vsn)) do
                      :undefined ->
                        "0.0.0"

                      {:ok, version} ->
                        version |> to_string()
                    end,
                  "license_type" => license["type_info"]["license_type_name"],
                  "license_expiration" => license["license_info"]["license_expiry"],
                  "license_rules" => license["active_rules"]
                }

                body = %{"status" => "success", "result" => result} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/get_interactor_info"
          - do:
              $action: "elixir"
              value: |
                {:ok, hostname} = :inet.gethostname()
                os_type = :os.type()
                os = ""
                interfaces = []

                cpu_model =
                  case(os_type) do
                    {_, :darwin} ->
                      :os.cmd('sysctl -a | grep machdep.cpu.brand_string')
                      |> to_string()
                      |> String.split("machdep.cpu.brand_string: ")
                      |> Enum.at(1)

                      os = "MacOS"

                      interfaces =
                        :os.cmd('ifconfig | grep "inet "')
                        |> to_string()
                        |> String.split(~r"\\\\\\\\\\\\\\\\R")
                        |> Enum.map(fn x -> String.split(x) end)

                    _ ->
                      ""
                  end

                system_stat =
                  Map.new()
                  |> Map.put("app_memory", :erlang.memory() |> Enum.into(%{}))
                  |> Map.put("app_processes", length(:erlang.processes()))
                  |> Map.put("app_active_tasks", :erlang.statistics(:total_active_tasks))
                  |> Map.put("architecture", :erlang.system_info(:system_architecture) |> to_string())
                  |> Map.put("cores", :erlang.system_info(:logical_processors))
                  |> Map.put("cpu", cpu_model)
                  |> Map.put("hostname", hostname |> to_string())
                  |> Map.put("interfaces", interfaces)
                  |> Map.put("os_type", os)
                  |> Map.put("os_version", :os.version() |> Tuple.to_list() |> Enum.join("."))
                  # |> Map.put("system_cpu", :cpu_sup.util())
                  # |> Map.put(
                  #   "system_disk",
                  #   :disksup.get_disk_data() |> Enum.map(fn {x, y, z} -> [x |> to_string(), y, z] end)
                  # )
                  |> Map.put("system_file_descriptor_count", :os.cmd('cat /proc/sys/fs/file-nr') |> to_string())
                  # |> Map.put("system_memory", :memsup.get_system_memory_data() |> Enum.into(%{}))
                  |> Map.put("system_uptime", :os.cmd('uptime') |> to_string())
                  |> Map.put(
                    "uptime",
                    (:erlang.system_time() - (:erlang.time_offset() + :erlang.system_info(:start_time))) /
                      1_000_000_000
                  )

                Log.info("system stat: #{inspect(system_stat)}")
                body = %{"status" => "success", "result" => system_stat} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/get_system_stat"
          - do:
              $action: "elixir"
              value: |
                # Log.info("data put: #{inspect v}")
                path = v["path"]["segment"]["data"] |> String.trim_trailing("/") |> String.split("/")
                # Log.info("data put: data: #{inspect v["body"]}")
                set(path, v["body"], flatten: true)
                # Log.info("data put: result: #{inspect get(path)}")
                body = %{"status" => "success", "result" => "data put"} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/data/{data} put"
          - do:
              $action: "elixir"
              value: |
                # Log.info("data get: #{inspect v}")
                path = v["path"]["segment"]["data"] |> String.trim_trailing("/") |> String.split("/")
                function("respond", %{"status" => "success", "result" => get(path)})
            model:
              $ref: "/api/data/{data} get"
          - do:
              $action: "elixir"
              value: |
                body = cond do
                  not is_map(v["body"])           -> %{"status" => "error", "result" => "Incorrect api structure"}
                  not is_list(v["body"]["path"])  -> %{"status" => "error", "result" => "Incorrect path structure"}
                  not is_map(v["body"]["value"])  -> %{"status" => "error", "result" => "Incorrect configuration structure"}
                  true                            ->
                    config_path = if v["body"]["path"], do: v["body"]["path"], else: []
                    set(["config"] ++ config_path, v["body"]["value"], flatten: true)
                    %{"status" => "success", "result" => "success"}
                end |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/config/add"
          - do:
              $action: "elixir"
              value: |
                function("save config")
                function("compile")
                function("respond", %{"status" => "success", "result" => "success"} |> Poison.encode!())
            model:
              $ref: "/api/config/commit"
          - do:
              $action: "elixir"
              value: |
                Log.info("config/setPath: " <> inspect(v))
                body = cond do
                  is_map(v["body"]) ->
                    path = ["config"] ++ v["body"]["path"]
                    set(path, v["body"]["value"], flatten: true)
                    # function("compile")
                    %{"status" => "success", "result" => v["body"]["value"]} |> Poison.encode!()
                  true ->
                    %{"status" => "error", "result" => "Incorrect configuration structure"} |> Poison.encode!()
                end
                function("respond", body)
            model:
              $ref: "/api/config/setPath"
          - do:
              $action: "elixir"
              value: |
                Log.info("config/removePath: " <> inspect(v))
                body = cond do
                  is_map(v["body"]) ->
                    path = ["config"] ++ v["body"]["path"]
                    clear(path)
                    # function("compile")
                    %{"status" => "success", "result" => v["body"]["path"]} |> Poison.encode!()
                  true ->
                    %{"status" => "error", "result" => "Incorrect configuration structure"} |> Poison.encode!()
                end
                function("respond", body)
            model:
              $ref: "/api/config/removePath"
          - do:
              $action: "elixir"
              value: |
                result = Interactor.Instance.get_status(Execution.State.new("edgehub_solution_default")) |> ISON.encode()

                body = %{"status" => "success", "result" => result} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/get_instance_status"
          - do:
              $action: "elixir"
              value: |
                Log.info("/api/admin/set_instance_status " <> inspect(v))
                result = if v["body"]["state"], do: Interactor.Instance.start(v["body"]["instance"], "edgehub_solution_default"), else: Interactor.Instance.stop(v["body"]["instance"], Execution.State.new("edgehub_solution_default"))
                Log.info("/api/admin/set_instance_status: result: " <> inspect(result))
                result = ''
                body = %{"status" => "success", "result" => result} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/set_instance_status"
          - do:
              $action: "elixir"
              value: |
                result = get(["stat"], default: "FAILED", project: "edgehub_solution_default")
                body = %{"status" => "success", "result" => result} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/get_device_stat"
          - model:
              $ref: "/api/admin/get_tag_stat"
          - do:
              $action: "elixir"
              value: |
                requested_keys = v["body"]["keys"]
                requested_path = v["body"]["path"]
                raw_string = get(["raw_string"] ++ requested_path, default: "FAILED", project: "edgehub_solution_default")
                raw = cond do
                  is_map(raw_string) -> raw_string |> Map.take(requested_keys)
                  true -> raw_string
                end
                binary_string = get(["binary_string"] ++ requested_path, default: "FAILED", project: "edgehub_solution_default")
                binary = cond do
                  is_map(binary_string) -> binary_string |> Map.take(requested_keys)
                  true -> binary_string
                end
                value_string = get(["value_string"] ++ requested_path, default: "FAILED", project: "edgehub_solution_default")
                value = cond do
                  is_map(value_string) -> value_string |> Map.take(requested_keys)
                  true -> value_string
                end
                body = %{"status" => "success", "result" => %{"raw" => raw, "binary" =>  binary, "value" => value}} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/get_tag_value_by_path"
          - do:
              $action: "elixir"
              value: |
                raw = get(["raw_string"],default: "FAILED", project: "edgehub_solution_default")
                binary = get(["binary_string"],default: "FAILED", project: "edgehub_solution_default")
                value = get(["value_string"],default: "FAILED", project: "edgehub_solution_default")
                body = %{"status" => "success", "result" => %{"raw" => raw, "binary" =>  binary, "value" => value}} |> Poison.encode!()
                function("respond", body)
            model:
              $ref: "/api/admin/get_tag_value"
        none:
           # Production mode
           $action: "http response"
           body:
             $action: "sequence"
             value:
               - $action: "match"
                 $set: "dir"
                 key: "path"
                 matches:
                   - model:
                       const: "/"
                     do: "/index.html"
                   - model:
                       type: "string"
                       pattern: "^/(js|css|fonts|img|favicon.ico)"
                     do:
                       $action: "get"
                       key: "path"
                 none: "/index.html"
               - $action: "function"
                 name: "read_file"

          # # Developement Mode
          #$action: "sequence"
          #value:
          #  - $action: "http request"
          #    $set: "response"
          #    headers:
          #      $action: "get"
          #      key: "headers"
          #    url:
          #      $action: "elixir"
          #      value: |
          #        "127.0.0.1:8081" <> v["path"]
          #  - $action: "http response"
          #    body:
          #      $action: "get"
          #      key:
          #        - "response"
          #        - "body"
          #    headers:
          #      $action: "elixir"
          #      value: |
          #        v["response"].headers |> Enum.into(%{})
    use: "http server"
  bootloader:
    data:
      count: 2
      interval: 100
    event:
      execute:
        $action: "elixir"
        value: |
          Log.info get("config")
          if (v["count"] > 1) do
            if (get("config") == nil) do
              set("config", get("defaultConfig"), flatten: true)
            end
            set("loaded", true)
          end
    use: "timer"
model:
  /api/add_first_user:
    $parser: "json"
    properties:
      path:
        const: "/api/add_first_user"
        type: "string"
    type: "object"
  /api/admin/get:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get"
        type: "string"
    type: "object"
  /api/admin/get_device_stat:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_device_stat"
        type: "string"
    type: "object"
  /api/admin/get_instance_status:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_instance_status"
        type: "string"
    type: "object"
  /api/admin/get_interactor_info:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_interactor_info"
        type: "string"
    type: "object"
  /api/admin/get_system_stat:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_system_stat"
        type: "string"
    type: "object"
  /api/admin/get_tag_stat:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_tag_stat"
        type: "string"
    type: "object"
  /api/admin/get_tag_value:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_tag_value"
        type: "string"
    type: "object"
  /api/admin/get_tag_value_by_path:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/get_tag_value_by_path"
        type: "string"
    type: "object"
  /api/admin/set:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/set"
        type: "string"
    type: "object"
  /api/admin/set_instance_status:
    $parser: "json"
    properties:
      path:
        const: "/api/admin/set_instance_status"
        type: "string"
    type: "object"
  /api/config/add:
    $parser: "json"
    properties:
      method:
        regex: "(?i)post"
        type: "string"
      path:
        const: "/api/config/add"
        type: "string"
    type: "object"
  /api/config/clear:
    $parser: "json"
    properties:
      path:
        const: "/api/config/clear"
        type: "string"
    type: "object"
  /api/config/commit:
    $parser: "json"
    properties:
      method:
        regex: "(?i)post"
        type: "string"
      path:
        const: "/api/config/commit"
        type: "string"
    type: "object"
  /api/config/default:
    $parser: "json"
    properties:
      path:
        const: "/api/config/default"
        type: "string"
    type: "object"
  /api/config/get:
    $parser: "json"
    properties:
      path:
        const: "/api/config/get"
        type: "string"
    type: "object"
  /api/config/removePath:
    $parser: "json"
    properties:
      path:
        const: "/api/config/removePath"
        type: "string"
    type: "object"
  /api/config/set:
    $parser: "json"
    properties:
      path:
        const: "/api/config/set"
        type: "string"
    type: "object"
  /api/config/setPath:
    $parser: "json"
    properties:
      path:
        const: "/api/config/setPath"
        type: "string"
    type: "object"
  /api/data/{data} get:
    $parser: "json"
    properties:
      method:
        regex: "(?i)get"
        type: "string"
      path:
        $parser: "path"
        pattern: "/data/{*data}"
    type: "object"
  /api/data/{data} put:
    $parser: "json"
    properties:
      method:
        regex: "(?i)put"
        type: "string"
      path:
        $parser: "path"
        pattern: "/data/{*data}"
    type: "object"
  /api/is_first_user:
    $parser: "json"
    properties:
      path:
        const: "/api/is_first_user"
        type: "string"
    type: "object"
  /api/log/clear:
    $parser: "json"
    properties:
      path:
        const: "/api/log/clear"
        type: "string"
    type: "object"
  /api/log/get:
    $parser: "json"
    properties:
      path:
        const: "/api/log/get"
        type: "string"
    type: "object"
  /api/login:
    $parser: "json"
    properties:
      path:
        const: "/api/login"
        type: "string"
    type: "object"
  /api/logout:
    $parser: "json"
    properties:
      path:
        const: "/api/logout"
        type: "string"
    type: "object"